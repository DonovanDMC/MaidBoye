async function (message) {
    const t = new utils_1.Timers((_config_1.default.developers.includes(message.author.id) || _config_1.default.beta) === true ? (label, info) => Logger_1.default.getLogger(label).debug(info) : false);
    if (message.author.bot === true || !("type" in message.channel) || message.channel.type === eris_1.default.Constants.ChannelTypes.GROUP_DM)
        return;
    t.start("userBl");
    const userBl = await UserConfig_1.default.prototype.checkBlacklist.call({ id: message.author.id });
    if (userBl.active.length > 0) {
        if (userBl.noticeNotShown.active.length > 0) {
            const bl = userBl.noticeNotShown.active[0];
            await message.reply(`H-hey! You've been blacklisted by a developer..\nDeveloper: **${bl.createdByTag}**\nReason: ${bl.reason ?? "None Provided."}\nExpiry: ${bl.expireTime === 0 ? "Never" : BotFunctions_1.default.formatDiscordTime(bl.expireTime, "short-datetime", true)}`);
            // we should only show one notice, as to not annoy them too much
            await Promise.all(userBl.noticeNotShown.active.map(async (b) => b.setNoticeShown(true)));
        }
        return;
    }
    t.end("userBl");
    t.start("dm");
    if (message.channel.type === eris_1.default.Constants.ChannelTypes.DM) {
        StatsHandler_1.default.trackBulkNoResponse("stats:directMessage", `stats:users:${message.author.id}:directMessage`);
        Logger_1.default.info(`Direct message recieved from ${message.author.tag} (${message.author.id}) | Content: ${message.content || "NONE"}${message.attachments.length !== 0 ? ` | Attachments: ${message.attachments.map((a, i) => `[${i}]: ${a.url}`).join(", ")}` : ""}`);
        return message.channel.createMessage({
            embeds: [
                new EmbedBuilder_1.default()
                    .setTitle("Hi!")
                    .setDescription(`H-hey... I see you direct messaged me.. If you need some help, y-you can join my support server.. <${_config_1.default.client.links.supprt}>\nMy default prefix is \`${_config_1.default.defaults.prefix.trim()}\`, and you can list my commands b-by using \`${_config_1.default.defaults.prefix}help\` in a server.\n\nI-if you don't want this response, run \`${_config_1.default.defaults.prefix}toggledmresponse\` in a server..`)
                    .setAuthor(message.author.tag, message.author.avatarURL)
                    .setFooter(">w<")
                    .toJSON()
            ]
        });
    }
    t.end("dm");
    // ignore if we can't send messages
    // (we need to check channel and guild to remove Uncached and PrivateChannel)
    if ("channel" in message && "guild" in message.channel && !message.channel.permissionsOf(this.user.id).has("sendMessages"))
        return;
    t.start("guildBl");
    const guildBl = await GuildConfig_1.default.prototype.checkBlacklist.call({ id: message.guildID });
    if (guildBl.active.length > 0) {
        if (guildBl.noticeNotShown.active.length > 0) {
            const bl = userBl.noticeNotShown.active[0];
            await message.reply(`H-hey! This server has been blacklisted by a developer..\nDeveloper: **${bl.createdByTag}**\nReason: ${bl.reason ?? "None Provided."}\nExpiry: ${bl.expireTime === 0 ? "Never" : BotFunctions_1.default.formatDiscordTime(bl.expireTime, "short-datetime", true)}`);
            // we should only show one notice, as to not annoy them too much
            await Promise.all(guildBl.noticeNotShown.active.map(async (b) => b.setNoticeShown(true)));
        }
        return;
    }
    t.end("guildBl");
    // we completely ignore messages inside of threads
    if ([
        eris_1.default.Constants.ChannelTypes.GUILD_NEWS_THREAD,
        eris_1.default.Constants.ChannelTypes.GUILD_PUBLIC_THREAD,
        eris_1.default.Constants.ChannelTypes.GUILD_PRIVATE_THREAD
    ].includes(message.channel.type))
        return;
    t.start("extend");
    const msg = new ExtendedMessage_1.default(message, this);
    t.end("extend");
    t.start("process");
    const load = await msg.load();
    t.end("process");
    if (msg.content.split(" ").slice(1).join(" ").replace(/go/, "").trim().toLowerCase().startsWith("make me"))
        return msg.reply("Th-that's not my purpose..");
    if (msg.content.split(" ").slice(1).join(" ").trim().toLowerCase().startsWith("fuck me"))
        return msg.reply("I-I don't even know you..");
    const { cmd } = msg;
    StatsHandler_1.default.trackNoResponse("stats", "message", msg.channel.typeString);
    if (load === false || cmd === null || msg.member === null)
        return;
    /* const user = await msg.getUserFromArgs();
    const member = await msg.getMemberFromArgs();
    const channel = await msg.getChannelFromArgs();
    const role = await msg.getRoleFromArgs();

    console.log(
        "dashedArgs:", msg.dashedArgs,
        "| args:", msg.args,
        "| rawArgs:", msg.rawArgs,
        "| prefix:", msg.prefix,
        "| cmd:", cmd.triggers[0],
        "\n",
        "getUserFromArgs:", user?.tag ?? null,
        "| getMemberFromArgs:", member?.tag ?? null,
        "| getChannelFromArgs:", channel?.name ?? null,
        "| getRoleFromArgs:", role?.name ?? null
    ); */
    // ignore commands in report channels
    if (/^user-report-([a-z\d]+)$/i.exec(msg.channel.name) && !cmd.triggers.includes("report"))
        return;
    if (!_config_1.default.developers.includes(msg.author.id)) {
        t.start("antispam");
        AntiSpam_1.default.add(msg.author.id, cmd, cmd.cooldown);
        const anti = AntiSpam_1.default.get(msg.author.id);
        if (anti.length !== 0 && (anti.length % _config_1.default.antiSpam.warnVL) === 0) {
            const report = BotFunctions_1.default.generateReport(msg.author, anti);
            Logger_1.default.getLogger("AntiSpam").info(`Possible command spam from ${msg.author.tag} (${msg.author.id}), VL: ${anti.length}, Report: ${report.url}`);
            await WebhookStore_1.default.execute("antispam", {
                embeds: [
                    new EmbedBuilder_1.default(true, msg.author)
                        .setTitle(`Possible Command Spam | VL: ${anti.length}`)
                        .setDescription(`Report: [${report.url}](${report.url})`)
                        .toJSON()
                ]
            });
            if (anti.length >= _config_1.default.antiSpam.maxVL) {
                const time = Date.now() + 2.592e+8;
                await UserConfig_1.default.prototype.addBlacklist.call({ id: msg.author.id }, this.user.id, "antispam", "Automatic blacklist due to spam.", time, report.id);
                Logger_1.default.getLogger("AntiSpam").info(`User ${msg.author.tag} (${msg.author.id}) has been automatically blacklisted for spam.`);
            }
        }
        t.end("antispam");
        t.start("restrictions");
        if (cmd.restrictions.includes("developer")) {
            StatsHandler_1.default.trackBulkNoResponse("stats:restrictionFail:developer", `stats:users:${msg.author.id}:restrictionFail:developer`);
            return msg.reply("H-hey! You aren't one of my developers!");
        }
        if (cmd.restrictions.includes("nsfw") && !msg.channel.nsfw) {
            StatsHandler_1.default.trackBulkNoResponse("stats:restrictionFail:nsfw", `stats:users:${msg.author.id}:restrictionFail:nsfw`);
            return msg.reply("H-hey! You have to use that in an nsfw channel!");
        }
        if (cmd.restrictions.includes("beta") && !_config_1.default.beta) {
            StatsHandler_1.default.trackBulkNoResponse("stats:restrictionFail:beta", `stats:users:${msg.author.id}:restrictionFail:beta`);
            return msg.reply("H-hey! This command can only be used in beta!");
        }
        const optionalUser = [];
        const missingUser = [];
        for (const [perm, optional] of cmd.userPermissions) {
            if (!msg.member.permissions.has(perm)) {
                if (optional)
                    optionalUser.push(perm);
                else
                    missingUser.push(perm);
            }
        }
        // I don't really know how to inform users of "optional" permissions right now
        if (missingUser.length > 0) {
            StatsHandler_1.default.trackBulkNoResponse(...missingUser.map(p => [
                `stats:missingPermission:user:${p}`,
                `stats:users:${msg.author.id}:missingPermission:user:${p}`
                //                                 typescript™️
            ]).reduce((a, b) => a.concat(b), []));
            return msg.reply(`H-hey! You're missing the ${utils_1.Strings.plural("permission", missingUser)} **${utils_1.Strings.joinAnd(missingUser.map(p => _config_1.default.permissions[p] || p), "**, **")}**.. You must have these to use this command!`);
        }
        // not starting this will throw an error
    }
    else
        t.start("restrictions");
    // we still check these when developers run commands
    const optionalBot = [];
    const missingBot = [];
    for (const [perm, optional] of cmd.botPermissions) {
        if (!msg.channel.guild.me.permissions.has(perm)) {
            if (optional)
                optionalBot.push(perm);
            else
                missingBot.push(perm);
        }
    }
    // @FIXME fix Strings#joinAnd boldness
    if (missingBot.length > 0) {
        StatsHandler_1.default.trackBulkNoResponse(...missingBot.map(p => [
            `stats:missingPermission:bot:${p}`,
            `stats:users:${msg.author.id}:missingPermission:bot:${p}`
            //                                 typescript™️
        ]).reduce((a, b) => a.concat(b), []));
        return msg.reply(`H-hey! I'm missing the ${utils_1.Strings.plural("permission", missingBot)} **${utils_1.Strings.joinAnd(missingBot.map(p => _config_1.default.permissions[p] || p), "**, **")}**.. I must have these for this command to function!`);
    }
    t.end("restrictions");
    StatsHandler_1.default.trackBulkNoResponse(`stats:commands:${cmd.triggers[0]}`, `stats:users:${msg.author.id}:commands:${cmd.triggers[0]}`);
    EventsASecondHandler_1.default.add("COMMANDS");
    EventsASecondHandler_1.default.add(`COMMANDS.${cmd.triggers[0].toUpperCase()}`);
    Logger_1.default.getLogger("CommandHandler").info(`Command ${cmd.triggers[0]} ran with ${msg.args.length === 0 ? "no arguments" : `the arguments "${msg.rawArgs.join(" ")}"`} by ${msg.author.tag} (${msg.author.id}) in the guild ${msg.channel.guild.name} (${msg.channel.guild.id})`);
    t.start("run");
    void cmd.run.call(this, msg, cmd)
        .then(res => {
        t.end("run");
        if (res instanceof Error)
            throw res;
    })
        .catch(async (err) => {
        if (err instanceof CommandError_1.default) {
            if (err.message === "INVALID_USAGE") {
                StatsHandler_1.default.trackBulkNoResponse(`stats:commands:${cmd.triggers[0]}:invalidUsage`, `stats:users:${msg.author.id}:commands:${cmd.triggers[0]}:invalidUsage`);
                return msg.reply(`H-hey! You didn't use that command right. check \`${msg.gConfig.getFormattedPrefix(0)}help ${cmd.triggers[0]}\` for info on how to use it..`);
            }
            return;
        }
        StatsHandler_1.default.trackNoResponse(`stats:commands:${cmd.triggers[0]}:error`);
        const code = await ErrorHandler_1.default.handleError(err, msg);
        if (code === null)
            return msg.reply("S-sorry! There was an error while running that.. Our internal error reporting service didn't return any further info.");
        else
            return msg.reply(`S-sorry! There was an error while running that.. I-if you want, you can report it to my developers, or try again later..\nCode: \`${code}\`\nSupport: ${_config_1.default.client.links.supprt}`);
    });
}