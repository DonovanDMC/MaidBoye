[
	{
		"birb": "async function (msg) {\n    const img = await (Math.random() > .5 ? Yiffy_1.default.animals.birb(\"json\", 1).then(y => y.url) : CheweyAPI_1.default.birb());\n    if (!img)\n        return msg.reply(\"The image api returned an error..\");\n    return msg.reply({\n        embeds: [\n            new EmbedBuilder_1.default(true, msg.author)\n                .setTitle(\"Birb!\")\n                .setImage(img)\n                .toJSON()\n        ]\n    });\n}"
	},
	{
		"bunny": "async function (msg) {\n    const img = await CheweyAPI_1.default.rabbit();\n    if (!img)\n        return msg.reply(\"The image api returned an error..\");\n    return msg.reply({\n        embeds: [\n            new EmbedBuilder_1.default(true, msg.author)\n                .setTitle(\"Bunny!\")\n                .setImage(img)\n                .toJSON()\n        ]\n    });\n}"
	},
	{
		"cat": "async function (msg) {\n    const img = await CheweyAPI_1.default.cat();\n    if (!img)\n        return msg.reply(\"The image api returned an error..\");\n    return msg.reply({\n        embeds: [\n            new EmbedBuilder_1.default(true, msg.author)\n                .setTitle(\"Kitty!\")\n                .setImage(img)\n                .toJSON()\n        ]\n    });\n}"
	},
	{
		"dikdik": "async function (msg) {\n    const img = await Yiffy_1.default.animals.dikdik(\"json\", 1);\n    if (!img)\n        return msg.reply(\"The image api returned an error..\");\n    return msg.reply({\n        embeds: [\n            new EmbedBuilder_1.default(true, msg.author)\n                .setTitle(\"Dik-Dik!\")\n                .setImage(img.url)\n                .toJSON()\n        ]\n    });\n}"
	},
	{
		"dog": "async function (msg) {\n    const img = await CheweyAPI_1.default.dog();\n    if (!img)\n        return msg.reply(\"The image api returned an error..\");\n    return msg.reply({\n        embeds: [\n            new EmbedBuilder_1.default(true, msg.author)\n                .setTitle(\"Woof Woof!\")\n                .setImage(img)\n                .toJSON()\n        ]\n    });\n}"
	},
	{
		"duck": "async function (msg) {\n    const img = await CheweyAPI_1.default.duck();\n    if (!img)\n        return msg.reply(\"The image api returned an error..\");\n    return msg.reply({\n        embeds: [\n            new EmbedBuilder_1.default(true, msg.author)\n                .setTitle(\"Duck!\")\n                .setImage(img)\n                .toJSON()\n        ]\n    });\n}"
	},
	{
		"fox": "async function (msg) {\n    const img = await CheweyAPI_1.default.fox();\n    if (!img)\n        return msg.reply(\"The image api returned an error..\");\n    return msg.reply({\n        embeds: [\n            new EmbedBuilder_1.default(true, msg.author)\n                .setTitle(\"Screeeeee!\")\n                .setImage(img)\n                .toJSON()\n        ]\n    });\n}"
	},
	{
		"koala": "async function (msg) {\n    const img = await CheweyAPI_1.default.koala();\n    if (!img)\n        return msg.reply(\"The image api returned an error..\");\n    return msg.reply({\n        embeds: [\n            new EmbedBuilder_1.default(true, msg.author)\n                .setTitle(\"Koala!\")\n                .setImage(img)\n                .toJSON()\n        ]\n    });\n}"
	},
	{
		"otter": "async function (msg) {\n    const img = await CheweyAPI_1.default.otter();\n    if (!img)\n        return msg.reply(\"The image api returned an error..\");\n    return msg.reply({\n        embeds: [\n            new EmbedBuilder_1.default(true, msg.author)\n                .setTitle(\"Cuuuute!\")\n                .setImage(img)\n                .toJSON()\n        ]\n    });\n}"
	},
	{
		"owl": "async function (msg) {\n    const img = await CheweyAPI_1.default.owl();\n    if (!img)\n        return msg.reply(\"The image api returned an error..\");\n    return msg.reply({\n        embeds: [\n            new EmbedBuilder_1.default(true, msg.author)\n                .setTitle(\"Hoot Hoot!\")\n                .setImage(img)\n                .toJSON()\n        ]\n    });\n}"
	},
	{
		"panda": "async function (msg) {\n    const img = await CheweyAPI_1.default.owl();\n    if (!img)\n        return msg.reply(\"The image api returned an error..\");\n    return msg.reply({\n        embeds: [\n            new EmbedBuilder_1.default(true, msg.author)\n                .setTitle(\"Panda!\")\n                .setImage(img)\n                .toJSON()\n        ]\n    });\n}"
	},
	{
		"snek": "async function (msg) {\n    const img = await CheweyAPI_1.default.snake();\n    if (!img)\n        return msg.reply(\"The image api returned an error..\");\n    return msg.reply({\n        embeds: [\n            new EmbedBuilder_1.default(true, msg.author)\n                .setTitle(\"Snek!\")\n                .setImage(img)\n                .toJSON()\n        ]\n    });\n}"
	},
	{
		"turtle": "async function (msg) {\n    const img = await CheweyAPI_1.default.turtle();\n    if (!img)\n        return msg.reply(\"The image api returned an error..\");\n    return msg.reply({\n        embeds: [\n            new EmbedBuilder_1.default(true, msg.author)\n                .setTitle(\"Turtle!\")\n                .setImage(img)\n                .toJSON()\n        ]\n    });\n}"
	},
	{
		"wah": "async function (msg) {\n    const img = await CheweyAPI_1.default.redPanda();\n    if (!img)\n        return msg.reply(\"The image api returned an error..\");\n    return msg.reply({\n        embeds: [\n            new EmbedBuilder_1.default(true, msg.author)\n                .setTitle(\"Wah!\")\n                .setImage(img)\n                .toJSON()\n        ]\n    });\n}"
	},
	{
		"wolf": "async function (msg) {\n    const img = await CheweyAPI_1.default.wolf();\n    if (!img)\n        return msg.reply(\"The image api returned an error..\");\n    return msg.reply({\n        embeds: [\n            new EmbedBuilder_1.default(true, msg.author)\n                .setTitle(\"Wolf!\")\n                .setImage(img)\n                .toJSON()\n        ]\n    });\n}"
	},
	{
		"blacklist": "async function (msg) {\n    if (msg.args.length < 3)\n        return msg.reply(\"Invalid usage..\");\n    switch (msg.args[0]?.toLowerCase()) {\n        case \"check\": {\n            const id = msg.args[2];\n            const type = msg.args[1].toLowerCase();\n            switch (type) {\n                case \"user\": {\n                    const user = await this.getUser(id);\n                    if (user === null)\n                        return msg.reply(\"Invalid user..\");\n                    const bl = await UserConfig_1.default.prototype.checkBlacklist.call({ id });\n                    return msg.reply(`The user **${user.tag}** has **${bl.active.length}** active blacklists, and **${bl.expired.length}** expired blacklists`);\n                }\n                case \"guild\": {\n                    const guild = this.guilds.get(id);\n                    if (guild === undefined)\n                        return msg.reply(\"Invalid guild..\");\n                    const bl = await GuildConfig_1.default.prototype.checkBlacklist.call({ id });\n                    return msg.reply(`The guild **${guild.name}** has **${bl.active.length}** active blacklists, and **${bl.expired.length}** expired blacklists`);\n                }\n            }\n            break;\n        }\n        case \"add\": {\n            const id = msg.args[2];\n            const type = msg.args[1].toLowerCase();\n            switch (type) {\n                case \"user\": {\n                    const user = await this.getUser(id);\n                    if (user === null)\n                        return msg.reply(\"Invalid user..\");\n                    const bl = await UserConfig_1.default.prototype.addBlacklist.call({ id }, msg.author.id, msg.author.tag, msg.args.slice(3).join(\" \") || null, msg.dashedArgs.keyValue.expiry === undefined ? 0 : Number(msg.dashedArgs.keyValue.expiry), null);\n                    return msg.reply(`Added a blacklist entry for **${user.tag}**, Reason: ${msg.args.slice(3).join(\" \") || \"None Provided.\"}\nID: ${bl.id}`);\n                }\n                case \"guild\": {\n                    const guild = this.guilds.get(id);\n                    if (guild === undefined)\n                        return msg.reply(\"Invalid guild..\");\n                    const bl = await GuildConfig_1.default.prototype.addBlacklist.call({ id }, msg.author.id, msg.author.tag, msg.args.slice(3).join(\" \") || null, msg.dashedArgs.keyValue.expiry === undefined ? 0 : Number(msg.dashedArgs.keyValue.expiry), null);\n                    return msg.reply(`Added a blacklist entry for **${guild.name}**, Reason: ${msg.args.slice(3).join(\" \") || \"None Provided.\"}\\nID: ${bl.id}`);\n                }\n            }\n            break;\n        }\n        default: return msg.reply(\"Invalid usage..\");\n    }\n}"
	},
	{
		"eval": "async function (msg) {\n    const evalVariables = {\n        Eris: eris_1.default,\n        db: _db_1.default,\n        Internal: utils_1.Internal,\n        Request: utils_1.Request,\n        Strings: utils_1.Strings,\n        Time: utils_1.Time,\n        Utility: utils_1.Utility,\n        BotFunctions: BotFunctions_1.default,\n        Redis: _db_1.default.r,\n        CommandHandler: CommandHandler_1.default,\n        UserConfig: UserConfig_1.default,\n        GuildConfig: GuildConfig_1.default,\n        currentUser: this.user.tag\n    };\n    // eslint-disable-next-line -- typescript messes with variable names so we have to remake them\n    for (const k in evalVariables)\n        new Function(\"value\", `${k} = value`)(evalVariables[k]);\n    let res;\n    const start = Timer_1.default.start();\n    try {\n        const ev = msg.rawArgs.join(\" \");\n        // eslint-disable-next-line no-eval\n        res = await eval(`(async()=>{${ev.indexOf(\"return\") === -1 ? \"return \" : \"\"}${ev}})()`);\n    }\n    catch (err) {\n        res = err;\n    }\n    const end = Timer_1.default.end();\n    const f = await format(res);\n    const t = Timer_1.default.calc(start, end, 3, false);\n    async function evalComponents(m) {\n        const wait = await msg.channel.awaitComponentInteractions(3e5, (it) => it.message.id === msg.author.id && it.message.id === m.id && it.data.custom_id.startsWith(\"eval-\"));\n        if (wait === null)\n            return m.edit({\n                components: []\n            });\n        if (wait.data.custom_id.includes(\"trash\"))\n            return m.delete();\n        else {\n            await msg.delete();\n            await m.edit({\n                components: m.components?.slice(0, 1)\n            });\n            void evalComponents.call(this, m);\n        }\n    }\n    if (res instanceof Error)\n        Logger_1.default.getLogger(\"Eval\").error(\"Eval Error:\", res);\n    if (msg.dashedArgs.value.includes(\"delete\") || msg.dashedArgs.value.includes(\"d\"))\n        await msg.delete().catch(() => null);\n    if (!(msg.dashedArgs.value.includes(\"silent\") || msg.dashedArgs.value.includes(\"s\"))) {\n        let file, out = String((msg.dashedArgs.value.includes(\"raw\") || msg.dashedArgs.value.includes(\"r\")) ? res : f);\n        if (out.length >= 750) {\n            try {\n                file = util_1.default.inspect(JSON.parse(out), { depth: 1 });\n            }\n            catch (e) {\n                file = out;\n            }\n            out = \"see attached file\";\n        }\n        const m = await msg.reply({\n            embeds: [\n                new EmbedBuilder_1.default()\n                    .setAuthor(msg.author.tag, msg.author.avatarURL)\n                    .setTitle(`Time Taken: ${t}`)\n                    .setColor(res instanceof Error ? \"red\" : \"green\")\n                    .addField(`${_config_1.default.emojis.default.in} Code`, `\\`\\`\\`js\n${msg.args.join(\" \").slice(0, 300)}\\`\\`\\``, false)\n                    .addField(`${_config_1.default.emojis.default.out}`, `\\`\\`\\`js\\n${out}\\`\\`\\``, false)\n                    .toJSON()\n            ],\n            components: new ComponentHelper_1.default()\n                // delete result\n                .addInteractionButton(ComponentHelper_1.default.BUTTON_DANGER, `eval-trash.${msg.author.id}`, false, ComponentHelper_1.default.emojiToPartial(_config_1.default.emojis.default.trash, \"default\"))\n                // delete invocation\n                .addInteractionButton(ComponentHelper_1.default.BUTTON_SECONDARY, `eval-delete.${msg.author.id}`, false, ComponentHelper_1.default.emojiToPartial(_config_1.default.emojis.default.x, \"default\"))\n                .toJSON()\n        }, file === undefined ? undefined : {\n            file,\n            name: \"output.txt\"\n        });\n        void evalComponents.call(this, m);\n    }\n    else {\n        Logger_1.default.getLogger(\"Eval\").info(\"Silent Eval Return (formatted):\", f);\n        Logger_1.default.getLogger(\"Eval\").info(\"Silent Eval Return (raw):\", res);\n        Logger_1.default.getLogger(\"Eval\").info(\"Silent Eval Time:\", t);\n    }\n}"
	},
	{
		"say": "async function (msg) {\n    if (msg.dashedArgs.value.includes(\"d\") || msg.dashedArgs.value.includes(\"delete\"))\n        await msg.delete();\n    return msg.channel.createMessage({\n        content: msg.args.join(\" \"),\n        messageReference: msg.dashedArgs.keyValue.reply === undefined || !/\\d{15,21}/.exec(msg.dashedArgs.keyValue.reply) ? undefined : {\n            messageID: msg.dashedArgs.keyValue.reply,\n            channelID: msg.channel.id,\n            guildID: msg.channel.guild.id\n        },\n        allowedMentions: {\n            repliedUser: !!msg.dashedArgs.keyValue.reply && msg.dashedArgs.value.includes(\"mention\")\n        },\n        stickerIDs: msg.dashedArgs.keyValue.sticker ? [msg.dashedArgs.keyValue.sticker] : []\n    });\n}"
	},
	{
		"update": "async function (msg) {\n    try {\n        const out = child_process_1.execSync(\"git pull\").toString();\n        const latest = child_process_1.execSync(\"git log -1\").toString().split(\"\n\").map(line => `> ${line}`);\n        latest[3] = \"> Commit Message:\";\n        if (latest.length === 6)\n            latest.splice(5);\n        const noChanges = out.includes(\"Already up to date.\");\n        const exit = msg.dashedArgs.value.includes(\"exit\");\n        await msg.reply(`Success.${noChanges ? `No changes were made. ${exit ? \" Not exiting.\" : \"\"}` : `${exit ? \" Exiting in 2 seconds.\" : \" Not exiting.\"}\\n\\nCommit Info:\\n${latest.join(\"\\n\")}`}\\n\\`\\`\\`sh\\nOutput:\\n${out}\\`\\`\\``);\n        await msg.channel.sendTyping();\n        if (exit && !noChanges)\n            setTimeout(() => process.exit(0), 2e3);\n    }\n    catch (e) {\n        Logger_1.default.getLogger(\"UpdateCommand\").error(\"Update Error\", e);\n        return msg.reply(\"There was an error, check the console.\");\n    }\n}"
	},
	{
		"8ball": "async function (msg) {\n    if (msg.args.length === 0)\n        return msg.reply(\"H-hey! You have to provide a question to ask..\");\n    const m = await msg.reply(\"Warning up..\");\n    async function main() {\n        const [text, image] = answers[Math.floor(Math.random() * answers.length)];\n        await m.edit({\n            embeds: [\n                new EmbedBuilder_1.default(true, msg.author)\n                    .setTitle(\"8ball Question\")\n                    .setDescription(text)\n                    .setImage(image)\n                    .setFooter(\"Disclaimer: Do not take any answers seriously!\")\n                    .toJSON()\n            ],\n            components: new ComponentHelper_1.default()\n                .addInteractionButton(ComponentHelper_1.default.BUTTON_PRIMARY, `8ball-new.${msg.author.id}`, undefined, undefined, \"New Answer\")\n                .addInteractionButton(ComponentHelper_1.default.BUTTON_PRIMARY, `8ball-exit.${msg.author.id}`, undefined, ComponentHelper_1.default.emojiToPartial(_config_1.default.emojis.default.x, \"default\"), \"Exit\")\n                .toJSON()\n        });\n        const wait = await msg.channel.awaitComponentInteractions(3e5, (it) => it.data.custom_id.startsWith(\"8ball-\") && it.message.id === m.id && it.member.id === msg.author.id);\n        if (wait === null) {\n            await m.edit({\n                components: []\n            });\n            return;\n        }\n        else {\n            await wait.acknowledge();\n            if (wait.data.custom_id.includes(\"new\"))\n                void main.call(this);\n            else {\n                await m.edit({\n                    components: []\n                });\n            }\n        }\n    }\n    void main.call(this);\n}"
	},
	{
		"awoo": "async function (msg) {\n    const e = new EmbedBuilder_1.default(true, msg.author)\n        .setTitle(\"Active Howl\")\n        .setDescription(`Howl Started By: <@!${msg.author.id}>\n${_config_1.default.emojis.custom.awoo}\\nCurrent Furs: **1**`);\n    const m = await msg.reply({\n        embeds: [\n            e.toJSON()\n        ],\n        components: new ComponentHelper_1.default()\n            .addInteractionButton(ComponentHelper_1.default.BUTTON_PRIMARY, \"awoo-join\", false, ComponentHelper_1.default.emojiToPartial(_config_1.default.emojis.custom.awoo, \"custom\"), \"Join Howl\")\n            .toJSON()\n    });\n    const current = [];\n    async function awaitJoin() {\n        const wait = await msg.channel.awaitComponentInteractions(3e5, (it) => it.message.id === m.id && it.data.custom_id === \"awoo-join\");\n        if (wait === null) {\n            await m.edit({\n                embeds: [\n                    e\n                        .setTitle(\"Howl Ended\")\n                        .toJSON()\n                ],\n                components: []\n            });\n            return;\n        }\n        else {\n            if (current.includes(wait.member.id) || wait.member.id === msg.author.id) {\n                void wait.createMessage({\n                    content: \"You are already in this howl!\",\n                    flags: 64\n                });\n            }\n            else {\n                current.push(wait.member.id);\n                await wait.acknowledge();\n                void m.edit({\n                    embeds: [\n                        e\n                            .setDescription(`Howl Started By: <@!${msg.author.id}>\\nCurrent Furs: **${current.length + 1}**\\n${_config_1.default.emojis.custom.awoo.repeat(current.length + 1)}\\n${current.map((c, i) => `<@!${c}> joined a howl with **${i + 1}** fur${(i + 1) !== 1 ? \"s\" : \"\"}`).join(\"\\n\")}`)\n                            .toJSON()\n                    ]\n                });\n            }\n            void awaitJoin.call(this);\n        }\n    }\n    void awaitJoin.call(this);\n}"
	},
	{
		"bap": "async function (msg, cmd) {\n    return BotFunctions_1.default.genericFunCommand.call(this, msg, cmd);\n}"
	},
	{
		"bellyrub": "async function (msg, cmd) {\n    return BotFunctions_1.default.genericFunCommand.call(this, msg, cmd);\n}"
	},
	{
		"blep": "async function (msg, cmd) {\n    return BotFunctions_1.default.genericFunCommandWithImage.call(this, msg, cmd, \"blep\");\n}"
	},
	{
		"boop": "async function (msg, cmd) {\n    return BotFunctions_1.default.genericFunCommandWithImage.call(this, msg, cmd, \"boop\");\n}"
	},
	{
		"conga": "async function (msg) {\n    if (msg.args.length === 0)\n        return msg.reply(\"H-hey! A user is required to start a conga..\");\n    const member = await msg.getMemberFromArgs();\n    if (member === null)\n        return msg.reply(\"H-hey! That wasn't a valid member..\");\n    if (member.id === msg.author.id)\n        return msg.reply(\"H-hey! You can't start a conga with yourself..\");\n    const e = new EmbedBuilder_1.default(true, msg.author)\n        .setTitle(\"Active Conga\")\n        .setDescription(`Conga Started By: <@!${msg.author.id}> with <@!${member.id}>\n${_config_1.default.emojis.custom.furdancing}\\nCurrent Furs: **2**`);\n    const m = await msg.reply({\n        embeds: [\n            e.toJSON()\n        ],\n        components: new ComponentHelper_1.default()\n            .addInteractionButton(ComponentHelper_1.default.BUTTON_PRIMARY, \"conga-join\", false, ComponentHelper_1.default.emojiToPartial(_config_1.default.emojis.custom.furdancing, \"custom\"), \"Join Conga\")\n            .toJSON()\n    });\n    const current = [member.id];\n    async function awaitJoin() {\n        const wait = await msg.channel.awaitComponentInteractions(3e5, (it) => it.message.id === m.id && it.data.custom_id === \"conga-join\");\n        if (wait === null) {\n            await m.edit({\n                embeds: [\n                    e\n                        .setTitle(\"Conga Ended\")\n                        .toJSON()\n                ],\n                components: []\n            });\n            return;\n        }\n        else {\n            if (current.includes(wait.member.id) || wait.member.id === msg.author.id) {\n                void wait.createMessage({\n                    content: \"You are already in this conga!\",\n                    flags: 64\n                });\n            }\n            else {\n                current.push(wait.member.id);\n                await wait.acknowledge();\n                void m.edit({\n                    embeds: [\n                        e\n                            .setDescription(`Conga Started By: <@!${msg.author.id}> with <@!${member.id}>\\nCurrent Furs: **${current.length + 1}**\\n${_config_1.default.emojis.custom.furdancing.repeat(current.length + 1)}\\n${current.slice(1).map((c, i) => `<@!${c}> joined a conga with **${i + 2}** furs`).join(\"\\n\")}`)\n                            .toJSON()\n                    ]\n                });\n            }\n            void awaitJoin.call(this);\n        }\n    }\n    void awaitJoin.call(this);\n}"
	},
	{
		"cuddle": "async function (msg, cmd) {\n    return BotFunctions_1.default.genericFunCommandWithImage.call(this, msg, cmd, \"cuddle\");\n}"
	},
	{
		"dadjoke": "async function (msg) {\n    const { joke } = await node_fetch_1.default(\"https://icanhazdadjoke.com\", {\n        method: \"GET\",\n        headers: {\n            \"Accept\": \"application/json\",\n            \"User-Agent\": _config_1.default.userAgent\n        },\n        timeout: 5e3\n    }).then(v => v.json());\n    // sauce: https://e926.net/posts/1535420\n    return msg.reply({\n        embeds: [\n            new EmbedBuilder_1.default(true, msg.author)\n                .setDescription(joke)\n                .setThumbnail(\"https://assets.maid.gay/dadjoke.png\")\n                .setColor(\"gold\")\n                .toJSON()\n        ]\n    });\n}"
	},
	{
		"dictionary": "async function (msg, cmd) {\n    return BotFunctions_1.default.genericFunCommand.call(this, msg, cmd);\n}"
	},
	{
		"divorce": "async function (msg) {\n    if (msg.uConfig.marriage === null)\n        return msg.reply(\"H-hey! You aren't married..\");\n    const m = await msg.reply({\n        embeds: [\n            new EmbedBuilder_1.default(true, msg.author)\n                .setTitle(\"Divorce\")\n                .setDescription(`Are you sure you want to divorce <@!${msg.uConfig.marriage}>?`)\n                .toJSON()\n        ],\n        components: new ComponentHelper_1.default()\n            .addInteractionButton(ComponentHelper_1.default.BUTTON_SECONDARY, `divorce-yes.${msg.author.id}`, false, undefined, \"Yes\")\n            .addInteractionButton(ComponentHelper_1.default.BUTTON_DANGER, `divorce-no.${msg.author.id}`, false, undefined, \"No\")\n            .toJSON()\n    });\n    const wait = await msg.channel.awaitComponentInteractions(3e5, (it) => it.message.id === m.id && it.member.user.id === msg.author.id && it.data.custom_id.startsWith(\"marry-\"));\n    if (wait === null || wait.data.custom_id.includes(\"no\"))\n        return m.edit({\n            content: \"Cancelled.\",\n            embeds: [],\n            components: []\n        });\n    await msg.uConfig.edit({ marriage: null });\n    await UserConfig_1.default.prototype.edit.call({ id: msg.uConfig.marriage }, { marriage: null });\n    return m.edit({\n        content: \"Done.\",\n        embeds: [],\n        components: []\n    });\n}"
	},
	{
		"flop": "async function (msg, cmd) {\n    return BotFunctions_1.default.genericFunCommandWithImage.call(this, msg, cmd, \"flop\");\n}"
	},
	{
		"furpile": "async function (msg) {\n    if (msg.args.length === 0)\n        return msg.reply(\"H-hey! A user is required to start a conga..\");\n    const member = await msg.getMemberFromArgs();\n    if (member === null)\n        return msg.reply(\"H-hey! That wasn't a valid member..\");\n    if (member.id === msg.author.id)\n        return msg.reply(\"H-hey! You can't start a conga with yourself..\");\n    const e = new EmbedBuilder_1.default(true, msg.author)\n        .setTitle(\"Active FurPile\")\n        .setDescription(`Furpile Started By: <@!${msg.author.id}> on <@!${member.id}>\n\\nCurrent Furs: **2**`);\n    const m = await msg.reply({\n        embeds: [\n            e.toJSON()\n        ],\n        components: new ComponentHelper_1.default()\n            .addInteractionButton(ComponentHelper_1.default.BUTTON_PRIMARY, \"furpile-join\", false, undefined, \"Join Furpile\")\n            .toJSON()\n    });\n    const current = [member.id];\n    async function awaitJoin() {\n        const wait = await msg.channel.awaitComponentInteractions(3e5, (it) => it.message.id === m.id && it.data.custom_id === \"furpile-join\");\n        if (wait === null) {\n            await m.edit({\n                embeds: [\n                    e\n                        .setTitle(\"Furpile Ended\")\n                        .toJSON()\n                ],\n                components: []\n            });\n            return;\n        }\n        else {\n            if (current.includes(wait.member.id) || wait.member.id === msg.author.id) {\n                void wait.createMessage({\n                    content: \"You are already in this furpile!\",\n                    flags: 64\n                });\n            }\n            else {\n                current.push(wait.member.id);\n                await wait.acknowledge();\n                void m.edit({\n                    embeds: [\n                        e\n                            .setDescription(`Furpile Started By: <@!${msg.author.id}> on <@!${member.id}>\\n\\n${current.slice(1).map((c, i) => `<@!${c}> joined a conga with **${i + 2}** furs`).join(\"\\n\")}`)\n                            .toJSON()\n                    ]\n                });\n            }\n            void awaitJoin.call(this);\n        }\n    }\n    void awaitJoin.call(this);\n}"
	},
	{
		"fursuit": "async function (msg) {\n    const butt = msg.args[0] === \"butt\";\n    let img = await Yiffy_1.default.furry.fursuit(\"json\", 1);\n    if (butt) {\n        if (!msg.channel.nsfw)\n            return msg.reply(\"H-hey! That has to be used in an nsfw channel..\");\n        img = await Yiffy_1.default.furry.butts(\"json\", 1);\n    }\n    if (!img)\n        return msg.reply(\"The image api returned an error..\");\n    return msg.reply({\n        embeds: [\n            new EmbedBuilder_1.default(true, msg.author)\n                .setTitle(`Fursuit${butt ? \" Butt\" : \"\"}`)\n                .setImage(img.url)\n                .toJSON()\n        ],\n        components: new ComponentHelper_1.default()\n            .addURLButton(img.shortURL, false, undefined, \"Full Image\")\n            .addURLButton(img.sources[0] || \"https://yiff.rest\", img.sources.length === 0, undefined, \"Source\")\n            .addURLButton(img.reportURL, false, undefined, \"Report\")\n            .toJSON()\n    });\n}"
	},
	{
		"gay": "async function (msg) {\n    const m = msg.args.length === 0 ? msg.member : await msg.getMemberFromArgs();\n    if (m === null)\n        return msg.reply(\"H-hey! That wasn't a valid user..\");\n    let img;\n    try {\n        img = await DankMemerAPI_1.default.gay(m.staticAvatarURL);\n    }\n    catch (err) {\n        Logger_1.default.getLogger(\"GayCommand\").error(err);\n        return msg.reply(\"Image api returned an error..\");\n    }\n    return msg.reply({\n        embeds: [\n            new EmbedBuilder_1.default(true, msg.author)\n                .setTitle(`${m.tag} But Gay`)\n                .setImage(\"attachment://gay.png\")\n                .toJSON()\n        ]\n    }, {\n        name: \"gay.png\",\n        file: img.file\n    });\n}"
	},
	{
		"gayrate": "async function (msg) {\n    const member = msg.args.length === 0 ? msg.member : await msg.getMemberFromArgs();\n    if (member === null)\n        return msg.reply(\"H-hey! That wasn't a valid member..\");\n    return msg.reply({\n        embeds: [\n            new EmbedBuilder_1.default(true, msg.author)\n                .setTitle(`${member.tag}'s Gayness`)\n                .setDescription(`**${member.tag}** is ${Math.floor(Math.random() * 101)}% gay!`)\n                .setThumbnail(\"https://assets.maid.gay/Gay.png\")\n                .toJSON()\n        ]\n    });\n}"
	},
	{
		"giphy": "async function (msg) {\n    if (msg.args.length < 1)\n        return msg.reply(\"H-hey! You have to provide something to search..\");\n    const { data } = await node_fetch_1.default(`https://api.giphy.com/v1/gifs/search?api_key=${_config_1.default.apiKeys.giphy}&q=${msg.args.join(\"%20\")}&limit=50&offset=7&rating=PG-13&lang=en`, {\n        method: \"GET\",\n        headers: {\n            \"User-Agent\": _config_1.default.userAgent\n        },\n        timeout: 5e3\n    }).then(v => v.json());\n    if (data.length === 0)\n        return msg.reply(\"That query returned no results..\");\n    return msg.channel.createMessage({\n        embeds: [\n            new EmbedBuilder_1.default(true, msg.author)\n                .setTitle(`Giphy Search: ${utils_1.Strings.truncate(msg.args.join(\" \"), 30)}`)\n                .setImage(data[Math.floor(Math.random() * data.length)].images.fixed_width.url)\n                .setTimestamp(new Date().toISOString())\n                .setColor(\"gold\")\n                .setThumbnail(\"https://assets.maid.gay/PoweredByGiphy.png\")\n                .setFooter(\"Images are provided by giphy, we are not responsible for their content.\")\n                .toJSON()\n        ]\n    });\n}"
	},
	{
		"glomp": "async function (msg, cmd) {\n    return BotFunctions_1.default.genericFunCommand.call(this, msg, cmd);\n}"
	},
	{
		"huff": "async function (msg, cmd) {\n    return BotFunctions_1.default.genericFunCommand.call(this, msg, cmd);\n}"
	},
	{
		"hug": "async function (msg, cmd) {\n    return BotFunctions_1.default.genericFunCommandWithImage.call(this, msg, cmd, \"hug\");\n}"
	},
	{
		"impostor": "async function (msg) {\n    const m = msg.args.length === 0 ? msg.member : await msg.getMemberFromArgs();\n    return msg.channel.createMessage({\n        content: [\n            \"。　　　　•　    　ﾟ　　。\",\n            \" 　　.　　　.　　　  　　.　　　　　。　　   。　.\",\n            \" 　.　　      。　        ඞ   。　    .    •\",\n            `    •                ${!m ? msg.args.join(\" \") : `<@!${m.id}>`} was ${Math.random() > .5 ? \"not\" : \"\"} An Impostor.   。  .`,\n            \"　 　　。　　 　　　　ﾟ　　　.　    　　　.\"\n        ].join(\"\n\"),\n        allowedMentions: {\n            users: false\n        }\n    });\n}"
	},
	{
		"kiss": "async function (msg, cmd) {\n    return BotFunctions_1.default.genericFunCommandWithImage.call(this, msg, cmd, \"kiss\");\n}"
	},
	{
		"lick": "async function (msg, cmd) {\n    return BotFunctions_1.default.genericFunCommandWithImage.call(this, msg, cmd, \"lick\");\n}"
	},
	{
		"marry": "async function (msg) {\n    if (msg.args.length < 1)\n        return msg.reply(\"H-hey! You have to provide someone to marry..\");\n    const member = await msg.getMemberFromArgs();\n    if (member === null)\n        return msg.reply(\"H-hey! That wasn't a valid member..\");\n    if (msg.uConfig.marriage !== null)\n        return msg.reply(\"H-Hey! You're already married..\");\n    if (msg.author.id === member.id)\n        return msg.reply(\"H-hey! You can't marry yourself..\");\n    if (member.bot === true)\n        return msg.reply(\"H-hey! You can't marry a bot..\");\n    const other = await _db_1.default.getUser(member.id);\n    if (other.marriage !== null)\n        return msg.reply(\"H-hey! They're already married..\");\n    const img = await Yiffy_1.default.furry.propose(\"json\", 1);\n    const m = await msg.reply({\n        embeds: [\n            new EmbedBuilder_1.default(true, msg.author)\n                .setTitle(\"Marriage Proposal\")\n                .setDescription(`<@!${msg.author.id}> has proposed to <@!${member.id}>!\n<@!${member.id}> do you accept?\\n\\n(this will time out at ${BotFunctions_1.default.formatDiscordTime(Date.now() + 3e5, \"short-time\")})`)\n                .setImage(img.url)\n                .toJSON()\n        ],\n        components: new ComponentHelper_1.default()\n            .addInteractionButton(ComponentHelper_1.default.BUTTON_SECONDARY, `marry-yes.${member.id}`, false, undefined, \"Yes\")\n            .addInteractionButton(ComponentHelper_1.default.BUTTON_DANGER, `marry-no.${member.id}`, false, undefined, \"No\")\n            .toJSON()\n    });\n    const wait = await msg.channel.awaitComponentInteractions(3e5, (it) => it.message.id === m.id && it.member.user.id === member.id && it.data.custom_id.startsWith(\"marry-\"));\n    if (wait === null || wait.data.custom_id.includes(\"no\"))\n        return m.edit({\n            content: \"Better luck next time..\",\n            embeds: [],\n            components: []\n        });\n    else {\n        await msg.uConfig.edit({\n            marriage: member.id\n        });\n        await other.edit({\n            marriage: msg.author.id\n        });\n        await m.edit({\n            content: \"\",\n            embeds: [\n                new EmbedBuilder_1.default(true, msg.author)\n                    .setTitle(\"Congrats!\")\n                    .setDescription(`Congrats <@!${msg.author.id}> and <@!${member.id}>`)\n                    .setImage(img.url)\n                    .toJSON()\n            ],\n            components: []\n        });\n    }\n}"
	},
	{
		"nap": "async function (msg, cmd) {\n    return BotFunctions_1.default.genericFunCommand.call(this, msg, cmd);\n}"
	},
	{
		"nuzzle": "async function (msg, cmd) {\n    return BotFunctions_1.default.genericFunCommand.call(this, msg, cmd);\n}"
	},
	{
		"pat": "async function (msg, cmd) {\n    return BotFunctions_1.default.genericFunCommand.call(this, msg, cmd);\n}"
	},
	{
		"poke": "async function (msg, cmd) {\n    return BotFunctions_1.default.genericFunCommand.call(this, msg, cmd);\n}"
	},
	{
		"pounce": "async function (msg, cmd) {\n    return BotFunctions_1.default.genericFunCommand.call(this, msg, cmd);\n}"
	},
	{
		"russianroulette": "async function (msg) {\n    const val = Math.floor(Math.random() * 6);\n    const bullets = typeof msg.args[0] !== \"undefined\" ? parseInt(msg.args[0], 10) : 3;\n    return msg.reply(`You ${val <= bullets - 1 ? \"died..\" : \"lived!\"}`);\n}"
	},
	{
		"ship": "async function (msg) {\n    let member1 = msg.member, member2, amount = Math.floor(Math.random() * 100) + 1;\n    if (Object.keys(msg.dashedArgs.keyValue).includes(\"percent\")) {\n        if (!_config_1.default.developers.includes(msg.author.id))\n            return msg.reply(\"H-hey! That option is limited to developers only..\");\n        amount = Number(msg.dashedArgs.keyValue.percent);\n    }\n    if (msg.args.length === 0)\n        member2 = msg.channel.guild.members.random() ?? null;\n    else if (msg.args.length === 1)\n        member2 = await msg.getMemberFromArgs(0, 0, true);\n    else {\n        member1 = await msg.getMemberFromArgs(0, 0, true);\n        member2 = await msg.getMemberFromArgs(1, 1, true);\n    }\n    if (member1 === null || member2 === null)\n        return msg.reply(\"H-hey! That wasn't a valid member..\");\n    if (!Object.keys(msg.dashedArgs.value).includes(\"random\"))\n        amount = Number((BigInt(member1.id) + BigInt(member2.id)) % 100n);\n    const ship = {\n        amount,\n        name: member1.username.slice(0, Math.floor(Math.random() * 5) + 3) + member2.username.slice(-(Math.floor(Math.random() * 5) + 3)),\n        get image() {\n            if (this.amount === 1)\n                return \"1-percent\";\n            else if (this.amount >= 2 && this.amount <= 19)\n                return \"2-19-percent\";\n            else if (this.amount >= 20 && this.amount <= 39)\n                return \"20-39-percent\";\n            else if (this.amount >= 40 && this.amount <= 59)\n                return \"40-59-percent\";\n            else if (this.amount >= 60 && this.amount <= 79)\n                return \"60-79-percent\";\n            else if (this.amount >= 80 && this.amount <= 99)\n                return \"80-99-percent\";\n            else if (this.amount === 100)\n                return \"100-percent\";\n            else\n                throw new Error(`Unexpected ship percentage \"${this.amount}\"`);\n        }\n    };\n    const img = await FluxPoint_1.default.customGen({\n        base: {\n            type: \"bitmap\",\n            x: 0,\n            y: 0,\n            width: 768,\n            height: 256,\n            color: \"0, 0, 0, 0\"\n        },\n        images: [\n            {\n                type: \"url\",\n                url: member1.user.avatarURL,\n                x: 0,\n                y: 0,\n                round: 0,\n                width: 256,\n                height: 256\n            },\n            {\n                type: \"url\",\n                url: `https://assets.maid.gay/ship/${ship.image}.png`,\n                x: 256,\n                y: 0,\n                round: 0,\n                width: 256,\n                height: 256\n            },\n            {\n                type: \"url\",\n                url: member2.user.avatarURL,\n                x: 512,\n                y: 0,\n                round: 0,\n                width: 256,\n                height: 256\n            }\n        ],\n        texts: [],\n        output: \"jpg\"\n    });\n    if (!(img instanceof Buffer)) {\n        Logger_1.default.error(\"FluxPoint Gen\", img);\n        throw new TypeError(\"Unknown Error\");\n    }\n    return msg.channel.createMessage({\n        embed: new EmbedBuilder_1.default(true, msg.author)\n            .setTitle(\"Shipping\")\n            .setDescription(`Shipping <@!${member1.id}> and <@!${member2.id}>\n**${ship.amount}%** - ${ship.name}`)\n            .setFooter(_config_1.default.emojis.default.blueHeart)\n            .setImage(\"attachment://ship.png\")\n            .toJSON()\n    }, {\n        file: img,\n        name: \"ship.png\"\n    });\n}"
	},
	{
		"slap": "async function (msg, cmd) {\n    return BotFunctions_1.default.genericFunCommand.call(this, msg, cmd);\n}"
	},
	{
		"sniff": "async function (msg, cmd) {\n    return BotFunctions_1.default.genericFunCommand.call(this, msg, cmd);\n}"
	},
	{
		"snowball": "async function (msg, cmd) {\n    return BotFunctions_1.default.genericFunCommand.call(this, msg, cmd);\n}"
	},
	{
		"spray": "async function (msg, cmd) {\n    return BotFunctions_1.default.genericFunCommand.call(this, msg, cmd);\n}"
	},
	{
		"wag": "async function (msg, cmd) {\n    return BotFunctions_1.default.genericFunCommand.call(this, msg, cmd);\n}"
	},
	{
		"whosagoodboi": "async function (msg) {\n    return msg.reply({\n        embeds: [\n            new EmbedBuilder_1.default(true, msg.author)\n                .setTitle(\"Who's A Good Boye?!?\")\n                .setDescription(msg.args.length === 0 ? \"You are! You're a good boye!\" : msg.args.join(\" \").includes(this.user.id) ? \"N-no! I am NOT a good boye.. nwn\" : `${msg.args.join(\" \")} is a good boye!`)\n                .toJSON()\n        ]\n    });\n}"
	},
	{
		"info": "async function (msg) {\n    return msg.reply({\n        embeds: [\n            new EmbedBuilder_1.default()\n                .setAuthor(msg.author.tag, msg.author.avatarURL)\n                .setDescription(\"**Stats/General**:\", `${_config_1.default.emojis.default.dot} System Memory: **${utils_1.Strings.formatBytes(os.totalmem() - os.freemem(), 2)}** / **${utils_1.Strings.formatBytes(os.totalmem(), 2)}**`, `${_config_1.default.emojis.default.dot} Process Memory: **${utils_1.Strings.formatBytes(process.memoryUsage().heapUsed, 2)}** / **${utils_1.Strings.formatBytes(process.memoryUsage().heapTotal, 2)}**`, `${_config_1.default.emojis.default.dot} CPU Usage: **${this.cpuUsage}%**`, `${_config_1.default.emojis.default.dot} Uptime: ${utils_1.Time.ms(process.uptime() * 1000, true)} (${utils_1.Time.secondsToHMS(process.uptime())})`, `${_config_1.default.emojis.default.dot} Shard: **${msg.channel.guild.shard.id + 1}**/**${this.shards.size}**`, `${_config_1.default.emojis.default.dot} Guilds: **${this.guilds.size}**`, `${_config_1.default.emojis.default.dot} Large Guilds: **${this.guilds.filter(g => g.large).length}**`, `${_config_1.default.emojis.default.dot} Channels: **${Object.keys(this.channelGuildMap).length}**`, `${_config_1.default.emojis.default.dot} Users: **${this.users.size}**`, `${_config_1.default.emojis.default.dot} Commands: **${CommandHandler_1.default.commands.length}** (**${CommandHandler_1.default.categories.length}** categories)`, \"\", \"**Developers**:\", `${_config_1.default.emojis.default.dot} [Creator] [Donovan_DMC](https://donovan.is.gay)`, \"\", \"**Other**:\", `${_config_1.default.emojis.default.dot} Library: [Eris Custom](https://github.com/DonovanDMC/eris/tree/merge) (**${eris_1.default.VERSION}**, \\`${package_lock_json_1.dependencies.eris.version.split(\"#\")[1].slice(0, 7)}\\`)`, `${_config_1.default.emojis.default.dot} API Version: **v${eris_1.default.Constants.REST_VERSION}**`, `${_config_1.default.emojis.default.dot} Gateway Version: **v${eris_1.default.Constants.GATEWAY_VERSION}**`, `${_config_1.default.emojis.default.dot} Version: **${package_json_1.default.version}** (Build Date: ${package_json_1.default.buildDate === null ? \"Unknown\" : `${String(package_json_1.default.buildDate).slice(0, 2)}/${String(package_json_1.default.buildDate).slice(2, 4)}/${String(package_json_1.default.buildDate).slice(4, 8)}`})`, `${_config_1.default.emojis.default.dot} Node Version: **${process.version}**`, `${_config_1.default.emojis.default.dot} Typescript Version: **${package_lock_json_1.dependencies.typescript.version}**`, `${_config_1.default.emojis.default.dot} Support Server: [${_config_1.default.client.links.supprt}](${_config_1.default.client.links.supprt})`)\n                .toJSON()\n        ]\n    });\n}"
	},
	{
		"ping": "async function (msg) {\n    const m = await msg.channel.createMessage(\"this will be edited soon\");\n    const start = perf_hooks_1.performance.now();\n    await m.edit(\"this will be deleted soon\");\n    const end = perf_hooks_1.performance.now();\n    await m.delete();\n    return msg.reply({\n        embeds: [new EmbedBuilder_1.default()\n                .setAuthor(msg.author.tag, msg.author.avatarURL)\n                .setTitle(\"Pong!\")\n                .setDescription(`\\ud83c\\udfd3 Gateway: **${msg.channel.guild.shard.latency}ms** | REST: **${(end - start).toFixed(0)}ms**`)\n                .setFooter(`UwU | Shard: ${msg.channel.guild.shard.id + 1}/${this.shards.size}`, _config_1.default.images.bot)\n                .toJSON()\n        ]\n    });\n}"
	},
	{
		"shards": "async function (msg) {\n    return msg.reply({\n        embeds: [\n            new EmbedBuilder_1.default()\n                .setAuthor(msg.author.tag, msg.author.avatarURL)\n                .addFields(...this.shards.map(s => ({\n                name: `Shard #${s.id}`,\n                value: [\n                    `Latency: ${_config_1.default.emojis.default[s.latency <= 75 ? \"green\" : s.latency <= 150 ? \"yellow\" : s.latency <= 250 ? \"orange\" : \"red\"]} ${s.latency}ms`,\n                    `Guilds: ${this.guilds.filter(g => g.shard.id === s.id).length}`,\n                    `Status: **${s.status}**`\n                ].join(\"\n\"),\n                inline: true\n            })))\n                .setFooter(`UwU | Average Latency: ${Math.floor(this.shards.reduce((a, b) => a + b.latency, 0) / this.shards.size)}ms`, _config_1.default.images.bot)\n                .toJSON()\n        ]\n    });\n}"
	},
	{
		"sinfo": "async function (msg) {\n    const o = await this.getUser(msg.channel.guild.ownerID);\n    const owner = o === null ? `Unknown#0000 (${msg.channel.guild.ownerID})` : `${o.username}#${o.discriminator} (${o.id})`;\n    const sections = {\n        // home\n        server: {\n            embeds: [\n                new EmbedBuilder_1.default()\n                    .setTitle(`Server Info - **${msg.channel.guild.name}**`)\n                    .setDescription(\"**Server**:\", `${_config_1.default.emojis.default.dot} Name: **${msg.channel.guild.name}**`, `${_config_1.default.emojis.default.dot} Id: **${msg.channel.guild.id}**`, `${_config_1.default.emojis.default.dot} Owner:** ${owner}**`, `${_config_1.default.emojis.default.dot} Creation Date: **${BotFunctions_1.default.formatDiscordTime(msg.channel.guild.createdAt, \"long-datetime\", true)}**`, `${_config_1.default.emojis.default.dot} Boosts: **${msg.channel.guild.premiumSubscriptionCount || \"None\"}**${!msg.channel.guild.premiumSubscriptionCount ? \"\" : ` (Tier: **${_config_1.default.names.boostTier[msg.channel.guild.premiumTier]}**)`}`, `${_config_1.default.emojis.default.dot} Large: **${msg.channel.guild.large ? \"Yes\" : \"No\"}**`, `${_config_1.default.emojis.default.dot} Verification Level: **${_config_1.default.names.verificationLevel[msg.channel.guild.verificationLevel]}**`, `${_config_1.default.emojis.default.dot} 2FA Requirement: **${msg.channel.guild.mfaLevel === 0 ? \"Disabled\" : \"Enabled\"}**`, `${_config_1.default.emojis.default.dot} Default Notifications: **${msg.channel.guild.defaultNotifications === 0 ? \"All Messages\" : \"Only Mentions\"}**`, `${_config_1.default.emojis.default.dot} Vanity URL: **${msg.channel.guild.features.includes(\"VANITY_URL\") && msg.channel.guild.vanityURL !== null ? `[https://discord.gg/${msg.channel.guild.vanityURL}](https://discord.gg/${msg.channel.guild.vanityURL})` : \"None\"}**`, `${_config_1.default.emojis.default.dot} NSFW level: ${[\"Default\", \"Explicit\", \"Safe\", \"Age Restricted\"][msg.channel.guild.nsfwLevel]}`, \"\", \"**Features**:\", msg.channel.guild.features.length === 0 ? `${_config_1.default.emojis.default.dot} NONE` : msg.channel.guild.features.map(f => `${_config_1.default.emojis.default.dot} ${_config_1.default.names.serverFeatures[f] ?? f}`))\n                    .setThumbnail(msg.channel.guild.iconURL ?? \"\")\n                    .toJSON()\n            ],\n            components: new ComponentHelper_1.default()\n                .addInteractionButton(ComponentHelper_1.default.BUTTON_PRIMARY, `sinfo-members.${msg.author.id}`, false, undefined, \"Members\")\n                .addInteractionButton(ComponentHelper_1.default.BUTTON_PRIMARY, `sinfo-channels.${msg.author.id}`, false, undefined, \"Channels\")\n                .addInteractionButton(ComponentHelper_1.default.BUTTON_PRIMARY, `sinfo-icon.${msg.author.id}`, false, undefined, \"Icon\")\n                .addInteractionButton(ComponentHelper_1.default.BUTTON_PRIMARY, `sinfo-splash.${msg.author.id}`, false, undefined, \"Splash\")\n                .addInteractionButton(ComponentHelper_1.default.BUTTON_PRIMARY, `sinfo-banner.${msg.author.id}`, false, undefined, \"Banner\")\n                .toJSON()\n        },\n        members: {\n            embeds: [\n                new EmbedBuilder_1.default()\n                    .setTitle(`Server Info - **${msg.channel.guild.name}**`)\n                    .setDescription(\"(the below counts will almost certainly be inaccurate)\", \"\", \"**Members**:\", `${_config_1.default.emojis.default.dot} Total: ${msg.channel.guild.memberCount}`, `${_config_1.default.emojis.default.dot} ${_config_1.default.emojis.custom.online}: ${msg.channel.guild.members.filter(m => m.status === \"online\").length}`, `${_config_1.default.emojis.default.dot} ${_config_1.default.emojis.custom.idle}: ${msg.channel.guild.members.filter(m => m.status === \"idle\").length}`, `${_config_1.default.emojis.default.dot} ${_config_1.default.emojis.custom.dnd}: ${msg.channel.guild.members.filter(m => m.status === \"dnd\").length}`, `${_config_1.default.emojis.default.dot} ${_config_1.default.emojis.custom.offline}: ${msg.channel.guild.members.filter(m => m.status === \"offline\").length}`, `${_config_1.default.emojis.default.dot} Non-Bots: ${msg.channel.guild.members.filter(m => !m.bot).length}`, `${_config_1.default.emojis.default.dot} Bots: ${msg.channel.guild.members.filter(m => m.bot).length}`)\n                    .setThumbnail(msg.channel.guild.iconURL ?? \"\")\n                    .toJSON()\n            ],\n            components: new ComponentHelper_1.default()\n                .addInteractionButton(ComponentHelper_1.default.BUTTON_PRIMARY, `sinfo-back.${msg.author.id}`, false, ComponentHelper_1.default.emojiToPartial(_config_1.default.emojis.default.back, \"default\"), \"Back\")\n                .toJSON()\n        },\n        channels: {\n            embeds: [\n                new EmbedBuilder_1.default()\n                    .setTitle(`Server Info - **${msg.channel.guild.name}**`)\n                    .setDescription(\"**Channels**:\", `${_config_1.default.emojis.default.dot} Total: ${msg.channel.guild.channels.size}`, `${_config_1.default.emojis.default.dot} Text: ${msg.channel.guild.channels.filter(c => c.type === eris_1.default.Constants.ChannelTypes.GUILD_TEXT).length}`, `${_config_1.default.emojis.default.dot} Voice: ${msg.channel.guild.channels.filter(c => c.type === eris_1.default.Constants.ChannelTypes.GUILD_VOICE).length}`, `${_config_1.default.emojis.default.dot} Category: ${msg.channel.guild.channels.filter(c => c.type === eris_1.default.Constants.ChannelTypes.GUILD_CATEGORY).length}`, `${_config_1.default.emojis.default.dot} News: ${msg.channel.guild.channels.filter(c => c.type === eris_1.default.Constants.ChannelTypes.GUILD_NEWS).length}`, `${_config_1.default.emojis.default.dot} Store: ${msg.channel.guild.channels.filter(c => c.type === eris_1.default.Constants.ChannelTypes.GUILD_STORE).length}`, `${_config_1.default.emojis.default.dot} Stage: ${msg.channel.guild.channels.filter(c => c.type === eris_1.default.Constants.ChannelTypes.GUILD_STAGE).length}`, \"\", `${_config_1.default.emojis.default.dot} Hidden (For You): ${msg.channel.guild.channels.filter(c => !c.permissionsOf(msg.author.id).has(\"viewChannel\")).length}`, `${_config_1.default.emojis.default.dot} Visible (For You): ${msg.channel.guild.channels.filter(c => c.permissionsOf(msg.author.id).has(\"viewChannel\")).length}`, \"\", `${_config_1.default.emojis.default.dot} Hidden (For Me): ${msg.channel.guild.channels.filter(c => !c.permissionsOf(this.user.id).has(\"viewChannel\")).length}`, `${_config_1.default.emojis.default.dot} Visible (For Me): ${msg.channel.guild.channels.filter(c => c.permissionsOf(this.user.id).has(\"viewChannel\")).length}`)\n                    .setThumbnail(msg.channel.guild.iconURL ?? \"\")\n                    .toJSON()\n            ],\n            components: new ComponentHelper_1.default()\n                .addInteractionButton(ComponentHelper_1.default.BUTTON_PRIMARY, `sinfo-back.${msg.author.id}`, false, ComponentHelper_1.default.emojiToPartial(_config_1.default.emojis.default.back, \"default\"), \"Back\")\n                .toJSON()\n        },\n        icon: {\n            embeds: [\n                (msg.channel.guild.iconURL === null ?\n                    new EmbedBuilder_1.default()\n                        .setTitle(`Server Info - **${msg.channel.guild.name}**`)\n                        .setDescription(\"This server does not have an icon.\")\n                    :\n                        new EmbedBuilder_1.default()\n                            .setTitle(`Server Info - **${msg.channel.guild.name}**`)\n                            .setImage(msg.channel.guild.iconURL)\n                            .setDescription(\"**Icon**:\", `${[512, 1024, 2048, 4096].map(size => `[[${size}]](${msg.channel.guild.iconURL.split(\"?\")[0]}?size=${size})`).join(\"  \")}`)).toJSON()\n            ],\n            components: new ComponentHelper_1.default()\n                .addInteractionButton(ComponentHelper_1.default.BUTTON_PRIMARY, `sinfo-back.${msg.author.id}`, false, ComponentHelper_1.default.emojiToPartial(_config_1.default.emojis.default.back, \"default\"), \"Back\")\n                .toJSON()\n        },\n        splash: {\n            embeds: [\n                (msg.channel.guild.splashURL === null ?\n                    new EmbedBuilder_1.default()\n                        .setTitle(`Server Info - **${msg.channel.guild.name}**`)\n                        .setDescription(\"This server does not have an invite splash.\")\n                    :\n                        new EmbedBuilder_1.default()\n                            .setTitle(`Server Info - **${msg.channel.guild.name}**`)\n                            .setImage(msg.channel.guild.splashURL)\n                            .setDescription(\"**Invite Splash**:\", `${[512, 1024, 2048, 4096].map(size => `[[${size}]](${msg.channel.guild.splashURL.split(\"?\")[0]}?size=${size})`).join(\"  \")}`)).toJSON()\n            ],\n            components: new ComponentHelper_1.default()\n                .addInteractionButton(ComponentHelper_1.default.BUTTON_PRIMARY, `sinfo-back.${msg.author.id}`, false, ComponentHelper_1.default.emojiToPartial(_config_1.default.emojis.default.back, \"default\"), \"Back\")\n                .toJSON()\n        },\n        banner: {\n            embeds: [\n                (msg.channel.guild.bannerURL === null ?\n                    new EmbedBuilder_1.default()\n                        .setTitle(`Server Info - **${msg.channel.guild.name}**`)\n                        .setDescription(\"This server does not have an invite banner.\")\n                    :\n                        new EmbedBuilder_1.default()\n                            .setTitle(`Server Info - **${msg.channel.guild.name}**`)\n                            .setImage(msg.channel.guild.bannerURL)\n                            .setDescription(\"**Invite Banner**:\", `${[512, 1024, 2048, 4096].map(size => `[[${size}]](${msg.channel.guild.bannerURL.split(\"?\")[0]}?size=${size})`).join(\"  \")}`)).toJSON()\n            ],\n            components: new ComponentHelper_1.default()\n                .addInteractionButton(ComponentHelper_1.default.BUTTON_PRIMARY, `sinfo-back.${msg.author.id}`, false, ComponentHelper_1.default.emojiToPartial(_config_1.default.emojis.default.back, \"default\"), \"Back\")\n                .toJSON()\n        }\n    };\n    let initialSection = msg.args.length === 0 ? \"server\" : msg.args[0].toLowerCase();\n    if (!Object.keys(sections).includes(initialSection))\n        initialSection = \"server\";\n    let m;\n    async function waitForEdit() {\n        if (m === undefined)\n            m = await msg.reply(sections[initialSection]);\n        const c = await msg.channel.awaitComponentInteractions(6e4, (it) => it.channelID === msg.channel.id && it.message.id === m.id && it.data.custom_id.startsWith(\"sinfo\") && it.data.custom_id.endsWith(msg.author.id) && it.member.user.id === msg.author.id);\n        if (c === null) {\n            await m.edit({\n                embeds: m.embeds,\n                components: []\n            });\n        }\n        else {\n            switch (c.data.custom_id.split(\".\")[0].split(\"-\")[1]) {\n                case \"members\": {\n                    await c.createMessage(sections.members);\n                    break;\n                }\n                case \"channels\": {\n                    await c.createMessage(sections.channels);\n                    break;\n                }\n                case \"icon\": {\n                    await c.createMessage(sections.icon);\n                    break;\n                }\n                case \"splash\": {\n                    await c.createMessage(sections.splash);\n                    break;\n                }\n                case \"banner\": {\n                    await c.createMessage(sections.banner);\n                    break;\n                }\n                case \"back\": {\n                    await c.createMessage(sections.server);\n                    break;\n                }\n            }\n            return void waitForEdit.call(this);\n        }\n    }\n    void waitForEdit.call(this);\n}"
	},
	{
		"stats": "async function (msg) {\n    const sql = await _db_1.default.getStats();\n    const sqlStart = Timer_1.default.getTime();\n    await _db_1.default.query(\"/* ping */ SELECT 1;\");\n    const sqlEnd = Timer_1.default.getTime();\n    const r = await Redis.info(\"stats\").then(v => v.split(/\n\\r?/).slice(1, -1).map(s => ({\n        [s.split(\":\")[0]]: Number(s.split(\":\")[1])\n    })).reduce((a, b) => ({ ...a, ...b }), {}));\n    const redisStart = Timer_1.default.getTime();\n    await Redis.ping();\n    const redisEnd = Timer_1.default.getTime();\n    const sec = EventsASecondHandler_1.default.get();\n    console.log(r);\n    return msg.reply({\n        embeds: [\n            new EmbedBuilder_1.default(true, msg.author)\n                .setTitle(\"Stats\")\n                .addField(\"Events\", await Promise.all(Object.entries(sec).filter(([key]) => ![\"GENERAL\"].includes(key) && !key.startsWith(\"COMMANDS\")).map(async ([key, value]) => {\n                const v = await Redis.get(`stats:events:${key}`);\n                return `${_config_1.default.emojis.default.dot} **${key}** ${value}/second (${(v ?? 0).toLocaleString(\"en-US\")} total)`;\n            })).then(v => v.join(\"\\n\")), false)\n                .addField(\"MariaDB\", sql === undefined ? \"None\" : [\n                `Ping: **${Timer_1.default.calc(sqlStart, sqlEnd, 2, false)}**`,\n                `Total Connections: **${sql.TOTAL_CONNECTIONS.toLocaleString(\"en-US\")}**`,\n                `Bytes Received: **${utils_1.Strings.formatBytes(Number(sql.BYTES_RECEIVED))}**`,\n                `Bytes Sent: **${utils_1.Strings.formatBytes(Number(sql.BYTES_SENT))}**`,\n                `Select Commands: **${sql.SELECT_COMMANDS.toLocaleString(\"en-US\")}**`,\n                `Update Commands: **${sql.UPDATE_COMMANDS.toLocaleString(\"en-US\")}**`,\n                `Other Commands: **${sql.OTHER_COMMANDS.toLocaleString(\"en-US\")}**`,\n                `Empty Queries: **${sql.EMPTY_QUERIES.toLocaleString(\"en-US\")}**`\n            ].join(\"\\n\"), true)\n                .addField(\"Redis\", [\n                `Ping: **${Timer_1.default.calc(redisStart, redisEnd, 2, false)}**`,\n                `Connections: **${r.total_connections_received.toLocaleString(\"en-US\")}**`,\n                `Commands Processed: **${r.total_commands_processed.toLocaleString(\"en-US\")}**`,\n                `Operations: **${r.instantaneous_ops_per_sec.toLocaleString(\"en-US\")}/second**`,\n                `Net In: **${utils_1.Strings.formatBytes(r.total_net_input_bytes)}**`,\n                `Net Out: **${utils_1.Strings.formatBytes(r.total_net_output_bytes)}**`\n            ].join(\"\\n\"), false)\n                .toJSON()\n        ]\n    });\n}"
	},
	{
		"uinfo": "async function (msg) {\n    let user = msg.args.length === 0 ? msg.author : await msg.getUserFromArgs();\n    // @FIXME banners don't seem to be sent over gateway yet\n    if (user && (user.banner === undefined || user.accentColor === undefined))\n        user = await this.getUser(user.id, true);\n    if (user === null)\n        return msg.reply(\"Th-that isn't a valid user..\");\n    const member = msg.channel.guild.members.get(user.id);\n    const sortedMembers = Array.from(msg.channel.guild.members.values()).sort((a, b) => (a.joinedAt ?? 0) - (b.joinedAt ?? 0));\n    let dRep, infr;\n    try {\n        dRep = await node_fetch_1.default(`https://discordrep.com/api/v3/rep/${user.id}`, {\n            headers: {\n                \"User-Agent\": _config_1.default.userAgent,\n                \"Authorization\": _config_1.default.apiKeys[\"discord-rep\"]\n            }\n        }).then(v => v.json());\n        infr = await node_fetch_1.default(`https://discordrep.com/api/v3/infractions/${user.id}`, {\n            headers: {\n                \"User-Agent\": _config_1.default.userAgent,\n                \"Authorization\": _config_1.default.apiKeys[\"discord-rep\"]\n            }\n        }).then(v => v.json());\n    }\n    catch (e) {\n        //\n    }\n    const badges = BotFunctions_1.default.getUserFlagsArray(user);\n    if (_config_1.default.developers.includes(user.id))\n        badges.push(\"DEVELOPER\");\n    if (badges.length === 0)\n        badges.push(\"NONE\");\n    const joinPosition = member && (sortedMembers.indexOf(member) + 1);\n    const joins = [];\n    // I didn't feel like making a function for this, so we do it manually\n    if (member && joinPosition) {\n        if (joinPosition === 1)\n            joins.push(member, ...sortedMembers.slice(1, 5));\n        else if (joinPosition === 2)\n            joins.push(sortedMembers[0], member, ...sortedMembers.slice(2, 5));\n        else if (joinPosition === (sortedMembers.length - 1))\n            joins.push(...sortedMembers.slice(-5, -2), member, sortedMembers[sortedMembers.length - 1]);\n        else if (joinPosition === (sortedMembers.length))\n            joins.push(...sortedMembers.slice(-5, -1), member);\n        else\n            joins.push(...sortedMembers.slice(joinPosition - 3, joinPosition - 1), member, ...sortedMembers.slice(joinPosition, joinPosition + 2));\n    }\n    return msg.reply({\n        embeds: [\n            new EmbedBuilder_1.default()\n                .setAuthor(msg.author.tag, msg.author.avatarURL)\n                .setTitle(`User Info for ${user.tag}`)\n                .setThumbnail(user.avatarURL)\n                .setDescription(\"**General User**:\", `${_config_1.default.emojis.default.dot} Tag: **${user.tag}**`, `${_config_1.default.emojis.default.dot} ID: **${user.id}**`, `${_config_1.default.emojis.default.dot} Avatar: [[Link](${user.avatarURL})]`, `${_config_1.default.emojis.default.dot} Banner: ${user.banner === null ? \"[None]\" : `[[Link](${user.bannerURL})] ${user.accentColor === null ? \"\" : `(#${user.accentColor.toString(16)})`}`}`, `${_config_1.default.emojis.default.dot} Creation Date: ${BotFunctions_1.default.formatDiscordTime(user.createdAt, \"long-datetime\", true)}`, member === undefined ? \"\" : [\n                \"\",\n                \"**Server Member**:\",\n                `${_config_1.default.emojis.default.dot} Join Date: ${member.joinedAt === null ? \"Unknown\" : BotFunctions_1.default.formatDiscordTime(member.joinedAt, \"long-datetime\", true)}`,\n                `${_config_1.default.emojis.default.dot} Roles: ${member.roles.length === 0 ? \"**None**\" : member.roles.reduce((a, b) => a + b.length + 4 /* <@&> */, 0) > 1500 ? \"**Unable To Display Roles.**\" : member.roles.map(r => `<@&${r}>`).join(\" \")}`,\n                `${_config_1.default.emojis.default.dot} Join Info:`,\n                ...joins.map(j => `${_config_1.default.emojis.default.dot} ${j.id === member.id ? `**#${sortedMembers.indexOf(j) + 1} ${j.tag}**` : `#${sortedMembers.indexOf(j) + 1} ${j.tag}`}`)\n            ], \"\", `[**DiscordRep**](https://discordrep.com/u/${user.id}):`, `${_config_1.default.emojis.default.dot} Rep: ${!dRep ? \"Unable to fetch data.\" : `${_config_1.default.emojis.custom[(dRep.upvotes - dRep.downvotes) > 0 ? \"upvote\" : (dRep.upvotes - dRep.downvotes) < 0 ? \"downvote\" : \"neutral\"]} ${dRep.upvotes - dRep.downvotes}`}`, `${_config_1.default.emojis.default.dot} Infractions: ${!infr ? \"Unable to fetch data.\" : `${infr.type === \"CLEAN\" ? \"None\" : `**${infr.type}**, Reason: ${infr.reason}, Timestamp: ${new Date(infr.date).toISOString()}`}`}`, \"\", \"**Badges**:\", badges.map(f => `${_config_1.default.emojis.default.dot} ${_config_1.default.names.badges[f]}`))\n                .setImage(user.bannerURL ?? \"\")\n                .toJSON()\n        ]\n    });\n}"
	},
	{
		"avatar": "async function (msg) {\n    const user = msg.args.length === 0 ? msg.author : await msg.getUserFromArgs();\n    if (user === null)\n        return msg.reply(\"Th-that isn't a valid user..\");\n    return msg.reply({\n        embeds: [\n            new EmbedBuilder_1.default()\n                .setAuthor(msg.author.tag, msg.author.avatarURL)\n                .setTitle(`Avatar of ${user.tag}`)\n                .setDescription(`[[512x512](${user.dynamicAvatarURL(undefined, 512)})] [[1024x1024](${user.dynamicAvatarURL(undefined, 1024)})]\n[[2048x2048](${user.dynamicAvatarURL(undefined, 2048)})] [[4096x4096](${user.dynamicAvatarURL(undefined, 4096)})]${user.id === this.user.id ? `\\n\\nIf you want to see the full version of my avatar, you can see it [here](${_config_1.default.images.botFull}).` : \"\"}`)\n                .setImage(user.dynamicAvatarURL(undefined, 4096))\n                .toJSON()\n        ]\n    });\n}"
	},
	{
		"donate": "async function (msg) {\n    return msg.reply({\n        embeds: [\n            new EmbedBuilder_1.default(true, msg.author)\n                .setTitle(\"Donate\")\n                .setAuthor(\"Maid Boye\", _config_1.default.images.bot, _config_1.default.client.links.kofi)\n                .setDescription(`[Donate At Ko-Fi](${_config_1.default.client.links.kofi})`)\n                .setImage(\"https://cdn.ko-fi.com/cdn/kofi1.png?v=2\")\n                .toJSON()\n        ]\n    });\n}"
	},
	{
		"help": "async function (msg) {\n    const m = await msg.reply(\"Warming up..\");\n    const eHome = new EmbedBuilder_1.default().setAuthor(msg.author.tag, msg.author.avatarURL);\n    const cHome = new ComponentHelper_1.default();\n    const hasUseExternal = msg.channel.permissionsOf(this.user.id).has(\"useExternalEmojis\");\n    const categories = {};\n    CommandHandler_1.default.categories.forEach((cat, i) => {\n        if (cat.restrictions.includes(\"disabled\") || (cat.restrictions.includes(\"beta\") && !_config_1.default.beta) || (cat.restrictions.includes(\"developer\") && !_config_1.default.developers.includes(msg.author.id)))\n            return;\n        eHome.addField(`${hasUseExternal && cat.displayName.emojiCustom ? `${cat.displayName.emojiCustom} ` : cat.displayName.emojiDefault ? `${cat.displayName.emojiDefault} ` : \"\"}${cat.displayName.text}`, `${cat.description || \"No Description.\"}\nTotal Commands: **${cat.commands.length}**`, true);\n        if ((i % 2) === 0)\n            eHome.addBlankField(true);\n        let emoji;\n        if (cat.displayName.emojiDefault !== null)\n            emoji = ComponentHelper_1.default.emojiToPartial(cat.displayName.emojiDefault, \"default\");\n        if (hasUseExternal && cat.displayName.emojiCustom !== null)\n            emoji = ComponentHelper_1.default.emojiToPartial(cat.displayName.emojiCustom, \"custom\");\n        cHome.addInteractionButton(ComponentHelper_1.default.BUTTON_SECONDARY, `help-${cat.name}.${msg.author.id}`, false, emoji);\n        const eCat = new EmbedBuilder_1.default()\n            .setTitle(`${cat.displayName.emojiCustom ?? cat.displayName.emojiDefault ?? \"\"} ${cat.displayName.text}`)\n            .setDescription(`Description: ${cat.description || \"None\"}\\nTotal Commands: ${cat.commands.length}\\n\\\\* - Has Slash Command Version`)\n            .setAuthor(msg.author.tag, msg.author.avatarURL);\n        const cmdDesc = [];\n        const totalLen = cat.commands.reduce((a, b) => a + `\\`${b.triggers[0]}\\` - ${b.description}\\n`.length, 0);\n        cat.commands.forEach(cmd => {\n            if (totalLen > 1900)\n                cmdDesc.push(`\\`${cmd.triggers[0]}\\``);\n            else\n                cmdDesc.push(`\\`${cmd.triggers[0]}\\`${cmd.hasSlashVariant ? \"\\\\*\" : \"\"} - ${cmd.description || \"No Description\"}`);\n        });\n        eCat.setDescription(`${eCat.getDescription() ?? \"\"}\\n\\n${totalLen > 1900 ? cmdDesc.join(\", \") : cmdDesc.join(\"\\n\")}`);\n        categories[cat.name] = {\n            content: \"\",\n            embeds: [eCat.toJSON()],\n            components: new ComponentHelper_1.default()\n                .addInteractionButton(ComponentHelper_1.default.BUTTON_SECONDARY, `help-home.${msg.author.id}`, false, ComponentHelper_1.default.emojiToPartial(_config_1.default.emojis.default.home, \"default\"), \"Home\")\n                .toJSON()\n        };\n    });\n    const home = {\n        content: \"\",\n        embeds: [eHome.toJSON()],\n        components: cHome.toJSON()\n    };\n    if (msg.args.length === 0)\n        void goHome.call(this);\n    else {\n        const cat = CommandHandler_1.default.getCategory(msg.args[0]);\n        if (cat !== null)\n            void goCat.call(this, cat.name);\n        else {\n            const cmd = CommandHandler_1.default.getCommand(msg.args[0]);\n            if (cmd !== null)\n                void goCommand.call(this, cmd);\n            else\n                return msg.reply(\"I-I couldn't find anything with what you provided..\");\n        }\n    }\n    async function goHome() {\n        await m.edit(home);\n        const wait = await msg.channel.awaitComponentInteractions(6e4, (it) => it.message.id === m.id && it.member.user.id === msg.author.id && it.data.custom_id.startsWith(\"help-\"));\n        if (wait === null) {\n            await m.edit({\n                content: \"\",\n                components: []\n            });\n            return;\n        }\n        else {\n            await wait.acknowledge();\n            void goCat.call(this, wait.data.custom_id.split(\".\")[0].split(\"-\")[1]);\n        }\n    }\n    async function goCat(name) {\n        await m.edit(categories[name]);\n        const wait = await msg.channel.awaitComponentInteractions(6e4, (it) => it.message.id === m.id && it.member.user.id === msg.author.id && it.data.custom_id.startsWith(\"help-home\"));\n        if (wait === null) {\n            await m.edit({\n                content: \"\",\n                components: []\n            });\n            return;\n        }\n        else {\n            await wait.acknowledge();\n            void goHome.call(this);\n        }\n    }\n    async function goCommand(cmd) {\n        const usage = await cmd.usage.call(this, msg, cmd);\n        if (typeof usage !== \"string\" && usage !== null)\n            await m.edit({\n                components: [],\n                embeds: [],\n                content: \"\",\n                ...usage\n            });\n        else {\n            const e = new EmbedBuilder_1.default()\n                .setTitle(\"Command Help\")\n                .setColor(\"green\")\n                .setDescription([\n                `Description: ${cmd.description || \"None\"}`,\n                `Usage: \\`${BotFunctions_1.default.formatPrefix(msg.gConfig)}${cmd.triggers[0]}${usage === null ? \"\" : ` ${usage}`}\\``,\n                `Restrictions: ${cmd.restrictions.length === 0 ? \"None\" : \"\"}`,\n                ...(cmd.restrictions.length === 0 ? [] : cmd.restrictions.map(r => `- **${utils_1.Strings.ucwords(r)}**`)),\n                \"\",\n                `User Permissions: ${cmd.userPermissions.length === 0 ? \"None\" : \"\"}`,\n                ...(cmd.userPermissions.length === 0 ? [] : [\"```diff\\n--- (red = optional)\", ...cmd.userPermissions.map(([perm, optional]) => `${optional ? \"-\" : \"+\"} ${_config_1.default.permissions[perm]}`), \"\\n```\"]),\n                `Bot Permissions: ${cmd.botPermissions.length === 0 ? \"None\" : \"\"}`,\n                ...(cmd.botPermissions.length === 0 ? [] : [\"```diff\\n--- (red = optional)\", ...cmd.botPermissions.map(([perm, optional]) => `${optional ? \"-\" : \"+\"} ${_config_1.default.permissions[perm]}`), \"\\n```\"])\n            ].join(\"\\n\"))\n                .setAuthor(msg.author.tag, msg.author.avatarURL);\n            await m.edit({\n                embeds: [e.toJSON()],\n                components: new ComponentHelper_1.default()\n                    .addInteractionButton(ComponentHelper_1.default.BUTTON_SECONDARY, `help-home.${msg.author.id}`, false, ComponentHelper_1.default.emojiToPartial(_config_1.default.emojis.default.home, \"default\"), \"Home\")\n                    .toJSON()\n            });\n        }\n        const wait = await msg.channel.awaitComponentInteractions(6e4, (it) => it.message.id === m.id && it.member.user.id === msg.author.id && it.data.custom_id.startsWith(\"help-home\"));\n        if (wait === null) {\n            await m.edit({\n                content: \"\",\n                components: []\n            });\n            return;\n        }\n        else {\n            await wait.acknowledge();\n            void goHome.call(this);\n        }\n    }\n}"
	},
	{
		"links": "async function (msg) {\n    return msg.reply({\n        embeds: [\n            new EmbedBuilder_1.default(true, msg.author)\n                .setTitle(\"Invite Info\")\n                .setDescription(`[Support Server](${_config_1.default.client.links.supprt})`, `[Twitter](${_config_1.default.client.links.twitter})`, `[Website](${_config_1.default.client.links.website})`, `[Developer](${_config_1.default.client.links.dev})`, `[Ko-Fi (Donate)](${_config_1.default.client.links.kofi})`, \"[Invite](https://maid.gay/closed-beta)\")\n                .toJSON()\n        ]\n    });\n}"
	},
	{
		"prefix": "async function (msg) {\n    switch (msg.args[0]) {\n        case \"add\": {\n            const space = msg.dashedArgs.value.includes(\"space\") || msg.dashedArgs.keyValue.space === \"true\";\n            if (msg.gConfig.prefix.length >= 10)\n                return msg.reply(\"H-hey! This server already has 10 prefixes, please remove some before you add more!\");\n            if ([...msg.gConfig.prefix.map(({ value }) => value), `<@${this.user.id}>`, `<@!${this.user.id}>`].includes(msg.args[1].toLowerCase()))\n                return msg.reply(\"H-hey! This server already has that as a prefix.\");\n            if (msg.args[1].toLowerCase().length > 25)\n                return msg.reply(\"H-hey! That prefix is too long..\");\n            await msg.gConfig.addPrefix(msg.args[1].toLowerCase(), space);\n            return msg.reply(`Successfully added **${msg.args[1].toLowerCase()}** to this server's prefixes.`);\n            break;\n        }\n        case \"remove\": {\n            if ([`<@${this.user.id}>`, `<@!${this.user.id}>`].includes(msg.args[1]))\n                return msg.reply(\"H-hey! You can't remove that prefix..\");\n            if (!msg.gConfig.prefix.map(({ value }) => value).includes(msg.args[1].toLowerCase()))\n                return msg.reply(\"H-hey! This server doesn't have that as one of its prefixes..\");\n            await msg.gConfig.removePrefix(msg.args[1].toLowerCase(), \"value\");\n            return msg.reply(`Successfully removed **${msg.args[1].toLowerCase()}** from this server's prefixes.`);\n            break;\n        }\n        case \"reset\": {\n            if (msg.gConfig.prefix.length === 1 && msg.gConfig.prefix[0].value === \"maid\")\n                return msg.reply(\"There isn't anything to reset?\");\n            await msg.gConfig.resetPrefixes();\n            return msg.reply(`Successfully reset this servers prefixes, you can use \\`${_config_1.default.defaults.prefix}\\`.`);\n            break;\n        }\n        case \"list\": {\n            return msg.reply({\n                embeds: [\n                    new EmbedBuilder_1.default()\n                        .setAuthor(msg.author.tag, msg.author.avatarURL)\n                        .setTitle(\"Prefix List\")\n                        .setDescription(`<@!${this.user.id}>`, msg.gConfig.prefix.map(({ value, space }) => `\\`${value}\\` (Space: ${space ? \"Yes\" : \"No\"})`))\n                        .toJSON()\n                ]\n            });\n            break;\n        }\n        default: {\n            return msg.reply({\n                embeds: [\n                    new EmbedBuilder_1.default()\n                        .setAuthor(msg.author.tag, msg.author.avatarURL)\n                        .setDescription([\n                        \"H-hey.. This command is a bit complicated, so here's some extra help!\",\n                        \"\",\n                        `Add Prefix: \\`${BotFunctions_1.default.formatPrefix(msg.gConfig)}prefix add <prefix>\\`\\\\*`,\n                        `Remove Prefix: \\`${BotFunctions_1.default.formatPrefix(msg.gConfig)}prefix remove <prefix>\\``,\n                        `Reset Prefixes: \\`${BotFunctions_1.default.formatPrefix(msg.gConfig)}prefix reset\\``,\n                        `List Prefixes: \\`${BotFunctions_1.default.formatPrefix(msg.gConfig)}prefix list\\``,\n                        `Note: mentions cannot be added or removed, you can always use <@!${this.user.id}> for commands`,\n                        \"\",\n                        \"\\\\* - If you want to use a space with your prefix:\",\n                        `\\`${BotFunctions_1.default.formatPrefix(msg.gConfig)}prefix add <prefix> --space\\``\n                    ].join(\"\n\"))\n                        .toJSON()\n                ]\n            });\n            break;\n        }\n    }\n}"
	},
	{
		"settings": "async function (msg) {\n    let page = 1;\n    const pages = chunk_1.default(Settings_1.default, 3);\n    function formatEmbed(v) {\n        return new EmbedBuilder_1.default(true, msg.author)\n            .setTitle(\"Server Settings\")\n            .setDescription(v.map(s => [\n            `${s.name === \"Default Yiff Type\" && msg.channel.nsfw ? _config_1.default.emojis.custom.knot : s.emoji?.value ?? \"\"} **${s.name}**`,\n            `${_config_1.default.emojis.default.dot} Current Value: ${s.displayFormat(msg.gConfig)}`,\n            `${_config_1.default.emojis.default.dot} Valid Values: ${s.validValuesDescription}`,\n            `${_config_1.default.emojis.default.dot} Description: ${s.description}`,\n            \"\"\n        ].join(\"\n\")).join(\"\\n\"))\n            .setFooter(`UwU | Page ${page}/${pages.length}`)\n            .toJSON();\n    }\n    const m = await msg.reply(\"Warming up..\");\n    async function changePage(id, token) {\n        const body = {\n            content: \"\",\n            embeds: [\n                formatEmbed(pages[page - 1])\n            ],\n            components: new ComponentHelper_1.default()\n                .addInteractionButton(ComponentHelper_1.default.BUTTON_PRIMARY, `settings-back.${msg.author.id}`, page === 1, ComponentHelper_1.default.emojiToPartial(_config_1.default.emojis.default.back, \"default\"), \"Back\")\n                .addInteractionButton(ComponentHelper_1.default.BUTTON_PRIMARY, `settings-configure.${msg.author.id}`, false, ComponentHelper_1.default.emojiToPartial(_config_1.default.emojis.custom.settings, \"custom\"), \"Configure\")\n                .addInteractionButton(ComponentHelper_1.default.BUTTON_PRIMARY, `settings-exit.${msg.author.id}`, false, ComponentHelper_1.default.emojiToPartial(_config_1.default.emojis.default.x, \"default\"), \"Exit\")\n                .addInteractionButton(ComponentHelper_1.default.BUTTON_PRIMARY, `settings-next.${msg.author.id}`, page === pages.length, ComponentHelper_1.default.emojiToPartial(_config_1.default.emojis.default.next, \"default\"), \"Next\")\n                .toJSON()\n            // string (MessageContent) isn't assignable to InteractionPayload\n        };\n        if (id && token)\n            await this.createInteractionResponse(id, token, { type: eris_1.default.Constants.InteractionResponseTypes.UPDATE_MESSAGE, data: body });\n        else\n            await m.edit(body);\n        const wait = await msg.channel.awaitComponentInteractions(6e4, (it) => it.data.custom_id.startsWith(\"settings-\") && it.member.user.id === msg.author.id && it.message.id === m.id);\n        if (wait === null)\n            return void m.edit({\n                content: \"\",\n                embeds: [\n                    new EmbedBuilder_1.default(true, msg.author)\n                        .setTitle(\"Server Settings\")\n                        .setDescription(\"Menu closed due to time out.\")\n                        .toJSON()\n                ],\n                components: []\n            });\n        else {\n            //  disabled buttons should keep this from going to an invalid page\n            if (wait.data.custom_id.includes(\"back\")) {\n                page--;\n                return void changePage.call(this, wait.id, wait.token);\n            }\n            else if (wait.data.custom_id.includes(\"next\")) {\n                page++;\n                return void changePage.call(this, wait.id, wait.token);\n            }\n            else if (wait.data.custom_id.includes(\"configure\")) {\n                const e = await configure.call(this, wait.id, wait.token);\n                if (e[0] === false)\n                    return;\n                else {\n                    // give them time to read the response\n                    if (e[1] === true)\n                        await new Promise(a => setTimeout(a, 3e3, undefined));\n                    return void changePage.call(this);\n                }\n            }\n            else\n                return void this.createInteractionResponse(wait.id, wait.token, {\n                    type: eris_1.default.Constants.InteractionResponseTypes.UPDATE_MESSAGE,\n                    data: {\n                        content: \"\",\n                        embeds: [\n                            new EmbedBuilder_1.default(true, msg.author)\n                                .setTitle(\"Server Settings\")\n                                .setDescription(\"Exited.\")\n                                .toJSON()\n                        ],\n                        components: []\n                    }\n                });\n        }\n    }\n    async function configure(id, token) {\n        await this.createInteractionResponse(id, token, {\n            type: eris_1.default.Constants.InteractionResponseTypes.UPDATE_MESSAGE,\n            data: {\n                content: \"\",\n                embeds: [\n                    formatEmbed(pages[page - 1])\n                ],\n                components: new ComponentHelper_1.default()\n                    .addSelectMenu(`settings-select.${msg.author.id}`, pages[page - 1].map(s => ({\n                    label: s.name,\n                    value: s.name.replace(/\\s/g, \"-\").toLowerCase(),\n                    // thanks Discord\n                    description: utils_1.Strings.truncate(s.shortDescription ?? s.description, 50),\n                    emoji: s.emoji === null ? undefined : ComponentHelper_1.default.emojiToPartial(s.name === \"Default Yiff Type\" && msg.channel.nsfw ? _config_1.default.emojis.custom.knot : s.emoji.value, s.emoji.type)\n                })), \"Select A Setting To Configure\", 1, 1)\n                    .addInteractionButton(ComponentHelper_1.default.BUTTON_PRIMARY, `settings-back.${msg.author.id}`, false, ComponentHelper_1.default.emojiToPartial(_config_1.default.emojis.default.back, \"default\"), \"Back\")\n                    .addInteractionButton(ComponentHelper_1.default.BUTTON_PRIMARY, `settings-exit.${msg.author.id}`, false, ComponentHelper_1.default.emojiToPartial(_config_1.default.emojis.default.x, \"default\"), \"Exit\")\n                    .toJSON()\n            }\n        });\n        const wait = await msg.channel.awaitComponentInteractions(6e4, (it) => it.data.custom_id.startsWith(\"settings-\") && it.member.user.id === msg.author.id && it.message.id === m.id);\n        if (wait === null) {\n            await m.edit({\n                content: \"\",\n                embeds: [\n                    new EmbedBuilder_1.default(true, msg.author)\n                        .setTitle(\"Server Settings\")\n                        .setDescription(\"Menu closed due to time out.\")\n                        .toJSON()\n                ],\n                components: []\n            });\n            return [false, false];\n        }\n        else {\n            if (wait.data.custom_id.includes(\"exit\")) {\n                await this.createInteractionResponse(wait.id, wait.token, {\n                    type: eris_1.default.Constants.InteractionResponseTypes.UPDATE_MESSAGE,\n                    data: {\n                        content: \"\",\n                        embeds: [\n                            new EmbedBuilder_1.default(true, msg.author)\n                                .setTitle(\"Server Settings\")\n                                .setDescription(\"Exited.\")\n                                .toJSON()\n                        ],\n                        components: []\n                    }\n                });\n                return [false, false];\n            }\n            await wait.acknowledge();\n            const v = !wait.data || !(\"values\" in wait.data) ? null : wait.data.values[0];\n            if (wait.data.custom_id.includes(\"back\"))\n                return [true, false];\n            const n = Settings_1.default.find(s => s.name.replace(/\\s/g, \"-\").toLowerCase() === v);\n            if (n === undefined) {\n                await m.edit({\n                    content: \"There was an internal error..\",\n                    embeds: [],\n                    components: []\n                });\n                return [false, false];\n            }\n            else\n                return n.exec(msg, m);\n        }\n    }\n    void changePage.call(this);\n}"
	},
	{
		"shorten": "async function (msg) {\n    if (msg.args.length < 1)\n        return msg.reply(\"H-hey! You have to provide a url to shorten..\");\n    if (msg.args[1] && msg.args[1].length > 50)\n        return msg.reply(\"H-hey! That code was too long..\");\n    void yiff_rocks_1.default.create(msg.args[0], `Discord:${msg.author.id}`, msg.args[1] || undefined, false)\n        .then((async (short) => msg.reply({\n        embeds: [\n            new EmbedBuilder_1.default(true, msg.author)\n                .setTitle(\"URL Shortened\")\n                .setDescription(`Code: \\`${short.code}\\`\nShort URL: [${short.fullURL}](${short.fullURL})`)\n                .toJSON()\n        ],\n        components: new ComponentHelper_1.default()\n            .addURLButton(short.fullURL, false, undefined, \"Open Link\")\n            .toJSON()\n    })), (async (err) => {\n        if (err instanceof yiff_rocks_1.APIError) {\n            if (err.obj === \"Invalid url proided.\")\n                return msg.reply(\"H-hey! That url was invalid..\");\n            else if (err.obj === \"Code already in use.\")\n                return msg.reply(\"H-hey! That code is already in use..\");\n            else\n                return msg.reply(`Our api returned an unknown error.. \\`${err.message}\\`, ${typeof err.obj === \"string\" ? err.obj : JSON.stringify(err.obj)}`);\n        }\n    }));\n}"
	},
	{
		"ban": "async function (msg, cmd) {\n    if (msg.args.length < 1)\n        return new CommandError_1.default(\"INVALID_USAGE\", cmd);\n    const nodm = msg.dashedArgs.value.includes(\"nodm\");\n    let delDays = Number(msg.dashedArgs.keyValue.deldays);\n    if (isNaN(delDays))\n        delDays = 1;\n    const user = await msg.getUserFromArgs();\n    if (user === null)\n        return msg.reply(\"Th-that wasn't a valid user..\");\n    const member = await this.getMember(msg.channel.guild.id, user.id);\n    if (member !== null) {\n        if (member.id === msg.author.id)\n            return msg.reply(\"I-I can't let you do that..\");\n        if (member.id === msg.channel.guild.ownerID)\n            return msg.reply(\"Y-you can't ban the server owner!\");\n        const compare = msg.member.compareToMember(member);\n        if ([\"higher\", \"same\"].includes(compare) && msg.member.id !== msg.channel.guild.ownerID)\n            return msg.reply(\"Th-that user is higher than, or as high as your highest role.. You cannot ban them\");\n        const compareMe = msg.channel.guild.me.compareToMember(member);\n        if ([\"higher\", \"same\"].includes(compareMe))\n            return msg.reply(\"Th-that user is higher than, or as high as my highest role.. I cannot ban them\");\n    }\n    let time = utils_1.Time.parseTime2(msg.args.slice(1)[msg.args.length - 1]), reason = null;\n    if (msg.args.length !== 1) {\n        if (time === 0) {\n            time = utils_1.Time.parseTime2(msg.args.join(\" \"));\n            reason = msg.args.slice(1).join(\" \");\n        }\n        else\n            reason = msg.args.slice(1, -1).join(\" \");\n        if (time < 1000)\n            time = 0;\n    }\n    if (time > 1.5768e11)\n        return msg.reply(\"H-hey! The maximum time is 5 years!\");\n    if (reason && reason.length > 500)\n        return msg.reply(\"Th-that reason is too long!\");\n    let dmError;\n    let dm = null;\n    if (!nodm && member !== null && !member.bot)\n        dm = await member.user.createMessage(`You were banned from **${msg.channel.guild.name}** by **${msg.author.tag}**\nReason:\\n\\`\\`\\`\\n${reason ?? \"None Provided\"}\\`\\`\\`\\nTime: **${time === 0 ? \"Permanent\" : utils_1.Time.ms(time, true, true, false)}**`)\n            .catch((err) => ((dmError = `${err.name}: ${err.message}`, null)));\n    await msg.channel.guild.banMember(user.id, delDays, `Ban: ${msg.author.tag} (${msg.author.id}) -> ${reason ?? \"None Provided\"}`)\n        // catch first so we only catch an error from ban\n        .catch(async (err) => {\n        // delete the dm if we didn't ban them\n        if (dm !== null)\n            await dm.delete().catch(() => null);\n        return msg.channel.createMessage(`I-I failed to ban **${user.tag}**..\\n\\`${err.name}: ${err.message}\\``);\n    })\n        .then(async () => {\n        const mdl = await ModLogHandler_1.default.createBanEntry(msg.gConfig, user, msg.author, reason, time, delDays);\n        return msg.channel.createMessage(`**${user.tag}** was banned ${time === 0 ? \"permanently\" : `for \\`${utils_1.Time.ms(time, true, true, false)}\\``}, ***${reason ?? \"None Provided\"}***${dmError !== undefined ? `\\n\\nFailed to send dm:\\n\\`${dmError}\\`` : \"\"}${mdl.check !== false ? `\\nFor more info, check <#${msg.gConfig.modlog.webhook.channelId}> (case: **#${mdl.entryId}**)` : \"\"}`);\n    });\n}"
	},
	{
		"inspect": "async function (msg) {\n    const debug = msg.dashedArgs.value.includes(\"debug\");\n    const member = await msg.getMemberFromArgs();\n    if (member === null)\n        return msg.reply(\"Th-that wasn't a valid member..\");\n    const user = await _db_1.default.getUser(member.id);\n    const strikes = await user.getStrikes(msg.channel.guild.id, true);\n    const pStrike = chunk_1.default(strikes.sort((a, b) => a.strikes[0].createdAt - b.strikes[0].createdAt), 5);\n    const totalStrikes = strikes.reduce((a, b) => a + b.strikes.length, 0);\n    //                                                                           warnings are on their own\n    const mod = await user.getModlogEntries(msg.gConfig).then(m => m.filter(v => !(v instanceof WarnEntry_1.default)));\n    const pMod = chunk_1.default(mod.sort((a, b) => a.createdAt - b.createdAt), 3);\n    const warnings = await user.getWarnings(msg.channel.guild.id);\n    const pWarnings = chunk_1.default(warnings.sort((a, b) => a.createdAt - b.createdAt), 5);\n    let page = -1;\n    const m = await msg.reply(\"Warming up..\");\n    async function main() {\n        await m.edit({\n            content: \"\",\n            embeds: [\n                new EmbedBuilder_1.default(true, msg.author)\n                    .setTitle(`Inspection: ${member.tag}`)\n                    .setDescription(`Total Strikes: **${totalStrikes}**`, `Total ModLog Entries: **${mod.length}**`, `Total Warnings: **${warnings.length}**`, \"\", `Most Recent Strike: ${totalStrikes === 0 ? \"Never\" : BotFunctions_1.default.formatDiscordTime(pStrike.slice(-1)[0].slice(-1)[0].strikes.slice(-1)[0].createdAt, \"relative\", true)}`, `Most Recent Moderation Action: ${pMod.length === 0 ? \"Never\" : BotFunctions_1.default.formatDiscordTime(pMod.slice(-1)[0].slice(-1)[0].createdAt, \"relative\", true)}`, `Most Recent Warning: ${pWarnings.length === 0 ? \"Never\" : BotFunctions_1.default.formatDiscordTime(pWarnings.slice(-1)[0].slice(-1)[0].createdAt, \"relative\", true)}`, \"(logs are sorted oldest to newest, top to bottom)\")\n                    .toJSON()\n            ],\n            components: new ComponentHelper_1.default()\n                .addInteractionButton(ComponentHelper_1.default.BUTTON_PRIMARY, `inspect-strikes.${msg.author.id}`, false, undefined, \"Strike History\")\n                .addInteractionButton(ComponentHelper_1.default.BUTTON_PRIMARY, `inspect-moderation.${msg.author.id}`, false, undefined, \"Moderation History\")\n                .addInteractionButton(ComponentHelper_1.default.BUTTON_PRIMARY, `inspect-warnings.${msg.author.id}`, false, undefined, \"Warning History\")\n                .toJSON()\n        });\n        const wait = await msg.channel.awaitComponentInteractions(3e5, (it) => it.data.custom_id.startsWith(\"inspect-\") && it.message.id === m.id && it.member.user.id === msg.author.id);\n        if (wait === null) {\n            await m.edit({\n                content: \"\",\n                embeds: [\n                    new EmbedBuilder_1.default(true, msg.author)\n                        .setTitle(\"Menu Closed\")\n                        .setDescription(\"Closed due to interaction timeout.\")\n                        .setColor(\"red\")\n                        .toJSON()\n                ],\n                components: []\n            });\n            return;\n        }\n        else {\n            await wait.acknowledge();\n            if (wait.data.custom_id.includes(\"strikes\"))\n                void strikeHistory.call(this);\n            else if (wait.data.custom_id.includes(\"moderation\"))\n                void moderationHistory.call(this);\n            else if (wait.data.custom_id.includes(\"warnings\"))\n                void warningHistory.call(this);\n            else\n                return;\n        }\n    }\n    async function strikeHistory() {\n        if (page === -1)\n            page = 1;\n        await m.edit({\n            content: \"\",\n            embeds: [\n                new EmbedBuilder_1.default(true, msg.author)\n                    .setTitle(`Strike History: ${member.tag}`)\n                    .setDescription(pStrike.length === 0 ? \"This user has no strike history.\" : await Promise.all(pStrike[page - 1].map(async (s) => {\n                    const blame = await this.getUser(s.strikes[0].createdBy);\n                    return `**${s.strikes.length}** strike${s.strikes.length !== 1 ? \"s\" : \"\"} added by \\`${blame === null ? s.strikes[0].createdBy : blame.tag}\\` on ${BotFunctions_1.default.formatDiscordTime(s.strikes[0].createdAt, \"short-datetime\", true)}${debug ? ` (group: \\`${s.id}\\`)` : \"\"}\n`;\n                })))\n                    .setFooter(pStrike.length === 0 ? \"UwU\" : `UwU | Page ${page}/${pStrike.length}`)\n                    .toJSON()\n            ],\n            components: new ComponentHelper_1.default()\n                .addInteractionButton(ComponentHelper_1.default.BUTTON_PRIMARY, `inspect-prev.${msg.author.id}`, pStrike.length === 0 || page === 1, ComponentHelper_1.default.emojiToPartial(_config_1.default.emojis.default.back, \"default\"), \"Previous Page\")\n                .addInteractionButton(ComponentHelper_1.default.BUTTON_PRIMARY, `inspect-home.${msg.author.id}`, false, ComponentHelper_1.default.emojiToPartial(_config_1.default.emojis.default.home, \"default\"), \"Home\")\n                .addInteractionButton(ComponentHelper_1.default.BUTTON_PRIMARY, `inspect-next.${msg.author.id}`, pStrike.length === 0 || page === pStrike.length, ComponentHelper_1.default.emojiToPartial(_config_1.default.emojis.default.next, \"default\"), \"Next Page\")\n                .toJSON()\n        });\n        const wait = await msg.channel.awaitComponentInteractions(3e5, (it) => it.data.custom_id.startsWith(\"inspect-\") && it.message.id === m.id && it.member.user.id === msg.author.id);\n        if (wait === null) {\n            await m.edit({\n                content: \"\",\n                embeds: [\n                    new EmbedBuilder_1.default(true, msg.author)\n                        .setTitle(\"Menu Closed\")\n                        .setDescription(\"Closed due to interaction timeout.\")\n                        .setColor(\"red\")\n                        .toJSON()\n                ],\n                components: []\n            });\n            return;\n        }\n        else {\n            await wait.acknowledge();\n            if (wait.data.custom_id.includes(\"prev\")) {\n                page--;\n                void strikeHistory.call(this);\n            }\n            else if (wait.data.custom_id.includes(\"home\")) {\n                page = -1;\n                void main.call(this);\n            }\n            else if (wait.data.custom_id.includes(\"next\")) {\n                page++;\n                void strikeHistory.call(this);\n            }\n            else\n                return;\n        }\n    }\n    async function moderationHistory() {\n        if (page === -1)\n            page = 1;\n        await m.edit({\n            content: \"\",\n            embeds: [\n                new EmbedBuilder_1.default(true, msg.author)\n                    .setTitle(`Moderation History: ${member.tag}`)\n                    .setDescription(pMod.length === 0 ? \"This user has no moderation history.\" : await Promise.all(pMod[page - 1].map(async (md) => `Case: **#${md.entryId}**\\nType: **${ModLogHandler_1.default.entryToString(md)}**\\nBlame: <@!${md.blame === \"automatic\" ? this.user.id : md.blame}>\\nReason: ${utils_1.Strings.truncate(md.reason ?? \"None Provided\", 50)}\\nDate Created: ${BotFunctions_1.default.formatDiscordTime(md.createdAt, \"short-datetime\", true)}${debug ? ` (id: \\`${md.id}\\`)` : \"\"}\\n`)))\n                    .setFooter(pMod.length === 0 ? \"UwU\" : `UwU | Page ${page}/${pMod.length}`)\n                    .toJSON()\n            ],\n            components: new ComponentHelper_1.default()\n                .addInteractionButton(ComponentHelper_1.default.BUTTON_PRIMARY, `inspect-prev.${msg.author.id}`, pMod.length === 0 || page === 1, ComponentHelper_1.default.emojiToPartial(_config_1.default.emojis.default.back, \"default\"), \"Previous Page\")\n                .addInteractionButton(ComponentHelper_1.default.BUTTON_PRIMARY, `inspect-home.${msg.author.id}`, false, ComponentHelper_1.default.emojiToPartial(_config_1.default.emojis.default.home, \"default\"), \"Home\")\n                .addInteractionButton(ComponentHelper_1.default.BUTTON_PRIMARY, `inspect-next.${msg.author.id}`, pMod.length === 0 || page === pMod.length, ComponentHelper_1.default.emojiToPartial(_config_1.default.emojis.default.next, \"default\"), \"Next Page\")\n                .toJSON()\n        });\n        const wait = await msg.channel.awaitComponentInteractions(3e5, (it) => it.data.custom_id.startsWith(\"inspect-\") && it.message.id === m.id && it.member.user.id === msg.author.id);\n        if (wait === null) {\n            await m.edit({\n                content: \"\",\n                embeds: [\n                    new EmbedBuilder_1.default(true, msg.author)\n                        .setTitle(\"Menu Closed\")\n                        .setDescription(\"Closed due to interaction timeout.\")\n                        .setColor(\"red\")\n                        .toJSON()\n                ],\n                components: []\n            });\n            return;\n        }\n        else {\n            await wait.acknowledge();\n            if (wait.data.custom_id.includes(\"prev\")) {\n                page--;\n                void moderationHistory.call(this);\n            }\n            else if (wait.data.custom_id.includes(\"home\")) {\n                page = -1;\n                void main.call(this);\n            }\n            else if (wait.data.custom_id.includes(\"next\")) {\n                page++;\n                void moderationHistory.call(this);\n            }\n            else\n                return;\n        }\n    }\n    async function warningHistory() {\n        if (page === -1)\n            page = 1;\n        await m.edit({\n            content: \"\",\n            embeds: [\n                new EmbedBuilder_1.default(true, msg.author)\n                    .setTitle(`Warning History: ${member.tag}`)\n                    .setDescription(pWarnings.length === 0 ? \"This user has no warning history.\" : await Promise.all(pWarnings[page - 1].map(async (w) => {\n                    const blame = await this.getUser(w.blameId);\n                    return `**#${w.warningId}**\\nBlame: \\`${blame === null ? w.blameId : blame.tag}\\`\\nReason: ${utils_1.Strings.truncate(w.reason ?? \"None Provided\", 50)}\\nDate Created: ${BotFunctions_1.default.formatDiscordTime(w.createdAt, \"short-datetime\", true)}${debug ? ` (id: \\`${w.id}\\`)` : \"\"}\\n`;\n                })))\n                    .setFooter(pWarnings.length === 0 ? \"UwU\" : `UwU | Page ${page}/${pWarnings.length}`)\n                    .toJSON()\n            ],\n            components: new ComponentHelper_1.default()\n                .addInteractionButton(ComponentHelper_1.default.BUTTON_PRIMARY, `inspect-prev.${msg.author.id}`, pWarnings.length === 0 || page === 1, ComponentHelper_1.default.emojiToPartial(_config_1.default.emojis.default.back, \"default\"), \"Previous Page\")\n                .addInteractionButton(ComponentHelper_1.default.BUTTON_PRIMARY, `inspect-home.${msg.author.id}`, false, ComponentHelper_1.default.emojiToPartial(_config_1.default.emojis.default.home, \"default\"), \"Home\")\n                .addInteractionButton(ComponentHelper_1.default.BUTTON_PRIMARY, `inspect-next.${msg.author.id}`, pWarnings.length === 0 || page === pWarnings.length, ComponentHelper_1.default.emojiToPartial(_config_1.default.emojis.default.next, \"default\"), \"Next Page\")\n                .toJSON()\n        });\n        const wait = await msg.channel.awaitComponentInteractions(3e5, (it) => it.data.custom_id.startsWith(\"inspect-\") && it.message.id === m.id && it.member.user.id === msg.author.id);\n        if (wait === null) {\n            await m.edit({\n                content: \"\",\n                embeds: [\n                    new EmbedBuilder_1.default(true, msg.author)\n                        .setTitle(\"Menu Closed\")\n                        .setDescription(\"Closed due to interaction timeout.\")\n                        .setColor(\"red\")\n                        .toJSON()\n                ],\n                components: []\n            });\n            return;\n        }\n        else {\n            await wait.acknowledge();\n            if (wait.data.custom_id.includes(\"prev\")) {\n                page--;\n                void warningHistory.call(this);\n            }\n            else if (wait.data.custom_id.includes(\"home\")) {\n                page = -1;\n                void main.call(this);\n            }\n            else if (wait.data.custom_id.includes(\"next\")) {\n                page++;\n                void warningHistory.call(this);\n            }\n            else\n                return;\n        }\n    }\n    switch (msg.args[1]?.toLowerCase()) {\n        case \"strike\":\n        case \"strikes\": return void strikeHistory.call(this);\n        case \"mod\":\n        case \"moderation\": return void moderationHistory.call(this);\n        case \"warning\":\n        case \"warnings\": return void warningHistory.call(this);\n        default: return void main.call(this);\n    }\n}"
	},
	{
		"kick": "async function (msg, cmd) {\n    if (msg.args.length < 1)\n        return new CommandError_1.default(\"INVALID_USAGE\", cmd);\n    const nodm = msg.dashedArgs.value.includes(\"nodm\");\n    const member = await msg.getMemberFromArgs();\n    if (member === null)\n        return msg.reply(\"Th-that wasn't a valid member..\");\n    if (member.id === msg.author.id)\n        return msg.reply(\"I-I can't let you do that..\");\n    if (member.id === msg.channel.guild.ownerID)\n        return msg.reply(\"Y-you can't kick the server owner!\");\n    const compare = msg.member.compareToMember(member);\n    if ([\"higher\", \"same\"].includes(compare) && msg.member.id !== msg.channel.guild.ownerID)\n        return msg.reply(\"Th-that user is higher than, or as high as your highest role.. You cannot kick them\");\n    const compareMe = msg.channel.guild.me.compareToMember(member);\n    if ([\"higher\", \"same\"].includes(compareMe))\n        return msg.reply(\"Th-that user is higher than, or as high as my highest role.. I cannot kick them\");\n    const reason = msg.args.slice(1).join(\" \");\n    if (reason && reason.length > 500)\n        return msg.reply(\"Th-that reason is too long!\");\n    let dmError;\n    let dm = null;\n    if (!nodm && member !== null && !member.bot)\n        dm = await member.user.createMessage(`You were kicked from **${msg.channel.guild.name}** by **${msg.author.tag}**\nReason:\\n\\`\\`\\`\\n${reason ?? \"None Provided\"}\\`\\`\\``)\n            .catch((err) => ((dmError = `${err.name}: ${err.message}`, null)));\n    await member.kick(`Kick: ${msg.author.tag} (${msg.author.id}) -> ${reason ?? \"None Provided\"}`)\n        // catch first so we only catch an error from ban\n        .catch(async (err) => {\n        // delete the dm if we didn't ban them\n        if (dm !== null)\n            await dm.delete().catch(() => null);\n        return msg.channel.createMessage(`I-I failed to kick **${member.tag}**..\\n\\`${err.name}: ${err.message}\\``);\n    })\n        .then(async () => {\n        const mdl = await ModLogHandler_1.default.createKickEntry(msg.gConfig, member, msg.author, `Kick: ${msg.author.tag} -> ${reason ?? \"None Provided\"}`);\n        return msg.channel.createMessage(`**${member.tag}** was kicked, ***${reason ?? \"None Provided\"}***${dmError !== undefined ? `\\n\\nFailed to send dm:\\n\\`${dmError}\\`` : \"\"}${mdl.check !== false ? `\\nFor more info, check <#${msg.gConfig.modlog.webhook.channelId}> (case: **#${mdl.entryId}**)` : \"\"}`);\n    });\n}"
	},
	{
		"lock": "async function (msg) {\n    const ch = (msg.args.length === 0 ? msg.channel : await msg.getChannelFromArgs());\n    if (ch === null)\n        return msg.reply(\"Th-that wasn't a valid channel..\");\n    // guild id = @everyone\n    const o = ch.permissionOverwrites.get(msg.channel.guild.id);\n    if (o) {\n        if (o.deny & eris_1.default.Constants.Permissions.sendMessages)\n            return msg.reply(`${ch.id === msg.channel.id ? \"Th-this\" : \"Th-that\"} channel is already locked!`);\n        if (o.allow & eris_1.default.Constants.Permissions.sendMessages)\n            o.allow -= eris_1.default.Constants.Permissions.sendMessages;\n    }\n    const reason = msg.args.length < 2 ? null : msg.args.slice(1).join(\" \");\n    if (reason && reason.length > 500)\n        return msg.reply(\"Th-that reason is too long!\");\n    await ch.editPermission(msg.channel.guild.id, o?.allow ?? 0n, (o?.deny ?? 0n) | eris_1.default.Constants.Permissions.sendMessages, 0, `Lock: ${msg.author.tag} (${msg.author.id}) -> ${reason ?? \"None Provided\"}`);\n    const mdl = await ModLogHandler_1.default.createLockEntry(msg.gConfig, ch, msg.member, reason);\n    await msg.reply(`Done.${mdl.check === false ? \"\" : ` (case #${mdl.entryId})`}`);\n    await ch.createMessage({\n        embeds: [\n            new EmbedBuilder_1.default()\n                .setTitle(\"Channel Locked\")\n                .setDescription(`This channel was locked by <@!${msg.author.id}>`, `Reason: \\`${reason ?? \"None Provided\"}\\``)\n                .setAuthor(msg.author.tag, msg.author.avatarURL)\n                .setColor(\"gold\")\n                .toJSON()\n        ]\n    });\n}"
	},
	{
		"lockdown": "async function (msg) {\n    const old = await Redis.get(`lockdown:${msg.channel.guild.id}`);\n    if (old)\n        return msg.reply(\"Th-this server has already been locked down..\");\n    const channels = msg.channel.guild.channels.filter(c => [eris_1.default.Constants.ChannelTypes.GUILD_TEXT, eris_1.default.Constants.ChannelTypes.GUILD_NEWS].includes(c.type));\n    const ovr = [];\n    const reason = msg.args.join(\" \") || null;\n    if (reason && reason.length > 500)\n        return msg.reply(\"Th-that reason is too long!\");\n    const m = await msg.reply(\"Running..\");\n    for (const ch of channels) {\n        const p = ch.permissionOverwrites.get(msg.channel.guild.id) ?? {\n            allow: 0n,\n            deny: 0n\n        };\n        // skip if send is already denied\n        if (p.deny & eris_1.default.Constants.Permissions.sendMessages)\n            continue;\n        else {\n            ovr.push([ch.id, p.allow.toString(), p.deny.toString()]);\n            if (p.allow & eris_1.default.Constants.Permissions.sendMessages)\n                p.allow -= eris_1.default.Constants.Permissions.sendMessages;\n            await ch.editPermission(msg.channel.guild.id, p.allow, p.deny | eris_1.default.Constants.Permissions.sendMessages, 0, `Lockdown: ${msg.author.tag} (${msg.author.id}) -> ${reason ?? \"None Provided\"}`);\n        }\n    }\n    if (ovr.length === 0)\n        return m.edit(\"No channels were locked.\");\n    await Redis.set(`lockdown:${msg.channel.guild.id}`, JSON.stringify(ovr));\n    const mdl = await ModLogHandler_1.default.createLockDownEntry(msg.gConfig, msg.member, reason);\n    await m.edit(`Locked **${ovr.length}** channels. ${mdl.check === false ? \"\" : ` (case #${mdl.entryId})`}`);\n}"
	},
	{
		"modlog": "async function (msg, cmd) {\n    if (msg.gConfig.modlog.enabled === true && msg.gConfig.modlog.webhook === null)\n        await msg.gConfig.edit({\n            modlog: _config_1.default.defaults.guild.modlog\n        });\n    const m = await msg.reply({\n        content: \"Please select a section from below.\n\\nIf you want to change a setting, you must use reset, then run setup again.\",\n        components: new ComponentHelper_1.default()\n            .addInteractionButton(ComponentHelper_1.default.BUTTON_PRIMARY, `modlog-section-setup.${msg.author.id}`, false, undefined, \"Setup\")\n            .addInteractionButton(ComponentHelper_1.default.BUTTON_PRIMARY, `modlog-section-reset.${msg.author.id}`, false, undefined, \"Reset\")\n            .addInteractionButton(ComponentHelper_1.default.BUTTON_PRIMARY, `modlog-section-get.${msg.author.id}`, false, undefined, \"Info\")\n            .toJSON()\n    });\n    let skip = false, sect;\n    if (msg.args.length !== 0 && [\"setup\", \"reset\", \"get\", \"info\"].includes(msg.args[0].toLowerCase())) {\n        sect = msg.args[0].toLowerCase();\n        skip = true;\n        await m.edit({\n            content: \"Successfully selected, processing..\",\n            components: []\n        });\n    }\n    if (skip === false) {\n        const section = await msg.channel.awaitComponentInteractions(6e4, (it) => it.channelID === msg.channel.id && it.message.id === m.id && it.data.custom_id.startsWith(\"modlog-section\") && it.data.custom_id.endsWith(msg.author.id) && it.member.user.id === msg.author.id);\n        if (section === null)\n            return m.edit({\n                content: \"Selection timed out..\",\n                components: []\n            });\n        await section.createMessage({\n            content: \"Successfully selected, processing..\",\n            components: []\n        });\n        sect = section.data.custom_id.split(\".\")[0].split(\"-\")[2];\n    }\n    switch (sect) {\n        case \"setup\": {\n            const check = await ModLogHandler_1.default.check(msg.gConfig);\n            if (check === true)\n                return msg.reply(`Th-this server's modlog has already been set up.. if you want to reset it, run \\`${msg.gConfig.getFormattedPrefix()}modlog reset\\``);\n            await m.edit(\"Please respond with a channel to use. (default: this channel)\");\n            const j = await msg.channel.awaitMessages(3e4, (mg) => mg.author.id === msg.author.id);\n            const ch = (!j ? msg.channel : await j.getChannelFromArgs(undefined, undefined, undefined, undefined, false));\n            if (ch === null)\n                return msg.reply(\"Th-that wasn't a valid channel!\");\n            if (j && msg.channel.permissionsOf(this.user.id).has(\"manageMessages\"))\n                await j.delete().catch(() => null);\n            await m.edit({\n                content: `Please select one of the following to proceed.\\n1.) Select an existing webhook (on <#${ch.id}>) to use for the modlog\\n2.) Provide a direct url to a webhook\\n3.) Create a new webhook (with me)`,\n                components: new ComponentHelper_1.default()\n                    .addInteractionButton(ComponentHelper_1.default.BUTTON_PRIMARY, `select-modlogsetup-1.${msg.author.id}`, false, ComponentHelper_1.default.emojiToPartial(_config_1.default.emojis.default.one, \"default\"), \"One\")\n                    .addInteractionButton(ComponentHelper_1.default.BUTTON_PRIMARY, `select-modlogsetup-2.${msg.author.id}`, false, ComponentHelper_1.default.emojiToPartial(_config_1.default.emojis.default.two, \"default\"), \"Two\")\n                    .addInteractionButton(ComponentHelper_1.default.BUTTON_PRIMARY, `select-modlogsetup-3.${msg.author.id}`, false, ComponentHelper_1.default.emojiToPartial(_config_1.default.emojis.default.three, \"default\"), \"Three\")\n                    .toJSON()\n            });\n            const sel = await msg.channel.awaitComponentInteractions(6e4, (it) => it.channelID === msg.channel.id && it.message.id === m.id && it.data.custom_id.startsWith(\"select-modlogsetup\") && it.data.custom_id.endsWith(msg.author.id) && it.member.user.id === msg.author.id);\n            if (sel === null)\n                return m.edit({\n                    content: \"Y-you took too long to respond..\",\n                    components: []\n                });\n            await sel.createMessage({\n                content: \"Successfully selected, processing..\",\n                components: []\n            });\n            // eslint-disable-next-line no-inner-declarations\n            async function configureOptions(message) {\n                const v = {\n                    ..._config_1.default.defaults.guild.modlog,\n                    enabled: true\n                };\n                // ask defaults\n                const selC = await message.channel.awaitComponentInteractions(3e4, (it) => it.channelID === msg.channel.id && it.message.id === message.id && it.data.custom_id.startsWith(\"modlogconfig\") && it.data.custom_id.endsWith(msg.author.id) && it.member.user.id === msg.author.id);\n                // defaults timeout\n                if (selC === null) {\n                    await message.edit({\n                        content: \"Detected timeout, using default configuration options. Setup complete!\",\n                        components: []\n                    });\n                    return v;\n                    // defaults no\n                }\n                else if (selC.data.custom_id.indexOf(\"no\") !== -1) {\n                    await selC.createMessage({\n                        content: \"Using default configuration options. Setup complete!\",\n                        components: []\n                    });\n                    return v;\n                }\n                else if (selC.data.custom_id.indexOf(\"cancel\") !== -1) {\n                    await selC.createMessage({\n                        content: \"Setup has been cancelled.\",\n                        components: []\n                    });\n                    return null;\n                }\n                // ask case editing\n                await selC.createMessage({\n                    content: \"Do you want to enable **Case Editing** after cases have been made? (default: **yes**)\",\n                    components: new ComponentHelper_1.default()\n                        .addInteractionButton(ComponentHelper_1.default.BUTTON_SUCCESS, `configCaseEditing-yes.${msg.author.id}`, false, undefined, \"Yes\")\n                        .addInteractionButton(ComponentHelper_1.default.BUTTON_DANGER, `configCaseEditing-no.${msg.author.id}`, false, undefined, \"No\")\n                        .addInteractionButton(ComponentHelper_1.default.BUTTON_PRIMARY, `configCaseEditing-exit.${msg.author.id}`, false, undefined, \"Exit\")\n                        .toJSON()\n                });\n                // case editing collector\n                const cnfCaseEditing = await ComponentInteractionCollector_1.default.awaitInteractions(msg.channel.id, 3e4, (it) => it.channelID === msg.channel.id && it.message.id === message.id && it.data.custom_id.startsWith(\"configCaseEditing\") && it.data.custom_id.endsWith(msg.author.id) && it.member.user.id === msg.author.id);\n                // buttons for case deletion, for less code duplication\n                const cnfCDComponents = new ComponentHelper_1.default()\n                    .addInteractionButton(ComponentHelper_1.default.BUTTON_SUCCESS, `configCaseDeletion-yes.${msg.author.id}`, false, undefined, \"Yes\")\n                    .addInteractionButton(ComponentHelper_1.default.BUTTON_DANGER, `configCaseDeletion-no.${msg.author.id}`, false, undefined, \"No\")\n                    .addInteractionButton(ComponentHelper_1.default.BUTTON_PRIMARY, `configCaseDeletion-exit.${msg.author.id}`, false, undefined, \"Exit\")\n                    .toJSON();\n                // case editing timeout\n                if (cnfCaseEditing === null)\n                    await message.edit({\n                        content: `Detected timeout, using default value for **Case Editing** (${v.caseEditingEnabled ? \"yes\" : \"no\"}).\\n\\nNext: Do you want to enable **Case Deletion**? (default: **${v.caseDeletingEnabled ? \"yes\" : \"no\"}**)`,\n                        components: cnfCDComponents\n                    });\n                // case editing no\n                else if (cnfCaseEditing.data.custom_id.indexOf(\"no\") !== -1) {\n                    await cnfCaseEditing.createMessage({\n                        content: `**Case Editing** has been set to disabled.\\n\\nNext: Do you want to enable **Case Deletion**? (default: **${v.caseDeletingEnabled ? \"yes\" : \"no\"}**)`,\n                        components: cnfCDComponents\n                    });\n                    v.caseEditingEnabled = false;\n                    // case editing yes\n                }\n                else if (cnfCaseEditing.data.custom_id.indexOf(\"yes\") !== -1) {\n                    await cnfCaseEditing.createMessage({\n                        content: `**Case Editing** has been set to enabled.\\n\\nNext: Do you want to enable **Case Deletion**? (default: **${v.caseDeletingEnabled ? \"yes\" : \"no\"}**)`,\n                        components: cnfCDComponents\n                    });\n                    v.caseEditingEnabled = true;\n                    // case editing exit\n                }\n                else if (cnfCaseEditing.data.custom_id.indexOf(\"exit\") !== -1) {\n                    await cnfCaseEditing.createMessage({\n                        content: \"Exiting.\",\n                        components: []\n                    });\n                    return v;\n                }\n                // case deletion collector\n                const cnfCaseDeletion = await ComponentInteractionCollector_1.default.awaitInteractions(msg.channel.id, 3e4, (it) => it.channelID === msg.channel.id && it.message.id === message.id && it.data.custom_id.startsWith(\"configCaseDeletion\") && it.data.custom_id.endsWith(msg.author.id) && it.member.user.id === msg.author.id);\n                // buttons for edit others cases, for less code duplication\n                const cnfEOCComponents = new ComponentHelper_1.default()\n                    .addInteractionButton(ComponentHelper_1.default.BUTTON_SUCCESS, `configEditOthersCases-yes.${msg.author.id}`, false, undefined, \"Yes\")\n                    .addInteractionButton(ComponentHelper_1.default.BUTTON_DANGER, `configEditOthersCases-no.${msg.author.id}`, false, undefined, \"No\")\n                    .addInteractionButton(ComponentHelper_1.default.BUTTON_PRIMARY, `configEditOthersCases-exit.${msg.author.id}`, false, undefined, \"Exit\")\n                    .toJSON();\n                // case deletion timeout\n                if (cnfCaseDeletion === null)\n                    await message.edit({\n                        content: `Detected timeout, using default value for **Case Deletion** (${v.caseDeletingEnabled ? \"yes\" : \"no\"}).\\n\\nNext: Do you want to enable **Editing Others Cases**? (default: **${v.editOthersCasesEnabled ? \"yes\" : \"no\"}**)`,\n                        components: cnfEOCComponents\n                    });\n                // case deletion no\n                else if (cnfCaseDeletion.data.custom_id.indexOf(\"no\") !== -1) {\n                    await cnfCaseDeletion.createMessage({\n                        content: `**Case Deletion** has been set to disabled.\\n\\nNext: Do you want to enable **Editing Others Cases**? (default: **${v.editOthersCasesEnabled ? \"yes\" : \"no\"}**)`,\n                        components: cnfEOCComponents\n                    });\n                    v.caseDeletingEnabled = false;\n                    // case deletion yes\n                }\n                else if (cnfCaseDeletion.data.custom_id.indexOf(\"yes\") !== -1) {\n                    await cnfCaseDeletion.createMessage({\n                        content: `**Case Deletion** has been set to enabled.\\n\\nNext: Do you want to enable **Editing Others Cases**? (default: **${v.editOthersCasesEnabled ? \"yes\" : \"no\"}**)`,\n                        components: cnfEOCComponents\n                    });\n                    v.caseDeletingEnabled = true;\n                    // case deletion exit\n                }\n                else if (cnfCaseDeletion.data.custom_id.indexOf(\"exit\") !== -1) {\n                    await cnfCaseDeletion.createMessage({\n                        content: \"Exiting.\",\n                        components: []\n                    });\n                    return v;\n                }\n                // edit others cases collector\n                const cnfEditOthersCases = await ComponentInteractionCollector_1.default.awaitInteractions(msg.channel.id, 3e4, (it) => it.channelID === msg.channel.id && it.message.id === message.id && it.data.custom_id.startsWith(\"configEditOthersCases\") && it.data.custom_id.endsWith(msg.author.id) && it.member.user.id === msg.author.id);\n                // edit others cases timeout\n                if (cnfEditOthersCases === null)\n                    await message.edit({\n                        content: `Detected timeout, using default value for **Edit Others Cases** (${v.editOthersCasesEnabled ? \"yes\" : \"no\"}).\\n\\nSetup is complete.`,\n                        components: []\n                    });\n                // edit others cases no\n                else if (cnfEditOthersCases.data.custom_id.indexOf(\"no\") !== -1) {\n                    await cnfEditOthersCases.createMessage({\n                        content: \"**Edit Others Cases** has been set to disabled.\\n\\nSetup is complete.\",\n                        components: []\n                    });\n                    v.editOthersCasesEnabled = false;\n                    // edit others cases yes\n                }\n                else if (cnfEditOthersCases.data.custom_id.indexOf(\"yes\") !== -1) {\n                    await cnfEditOthersCases.createMessage({\n                        content: \"**Edit Others Cases** has been set to enabled.\\n\\nSetup is complete.\",\n                        components: []\n                    });\n                    v.editOthersCasesEnabled = true;\n                    // edit others cases exit\n                }\n                else if (cnfEditOthersCases.data.custom_id.indexOf(\"exit\") !== -1) {\n                    await cnfEditOthersCases.createMessage({\n                        content: \"Exiting.\",\n                        components: []\n                    });\n                    return v;\n                }\n                return v;\n            }\n            let hook;\n            switch (Number(sel.data.custom_id.split(\".\")[0].split(\"-\")[2])) {\n                // select\n                case 1: {\n                    const hooks = await ch.getWebhooks();\n                    if (hooks.length === 0)\n                        return m.edit(\"Th-that channel doesn't have any webhooks to use..\");\n                    const c = new ComponentHelper_1.default();\n                    let i = 0;\n                    for (const w of hooks) {\n                        i++;\n                        c.addInteractionButton(ComponentHelper_1.default.BUTTON_PRIMARY, `select-webhook-${i - 1}.${msg.author.id}`, !w.token, ComponentHelper_1.default.emojiToPartial(_config_1.default.emojis.default[_config_1.default.names.number[i]], \"default\"), w?.name || \"Unknown\");\n                        if ((i % 2) === 0)\n                            c.addRow();\n                    }\n                    await m.edit({\n                        content: \"Please select a webhook from the following.\\n(if the button is disabled, we couldn't get all of the info we needed about the webhook)\",\n                        components: c.toJSON()\n                    });\n                    const selW = await ComponentInteractionCollector_1.default.awaitInteractions(msg.channel.id, 6e4, (it) => it.channelID === msg.channel.id && it.message.id === m.id && it.data.custom_id.startsWith(\"select-webhook\") && it.data.custom_id.endsWith(msg.author.id) && it.member.user.id === msg.author.id);\n                    if (selW === null)\n                        return m.edit({\n                            content: \"Y-you took too long to respond..\",\n                            components: []\n                        });\n                    hook = hooks[Number(selW.data.custom_id.split(\".\")[0].split(\"-\")[2])];\n                    if (!hook)\n                        return selW.createMessage({\n                            content: \"Internal error.\",\n                            components: []\n                        });\n                    await selW.createMessage({\n                        content: `Successfully selected the webhook **${hook.name}** (${hook.id})\\nWould you like to configure the more detailed options, or leave them at their defaults?`,\n                        components: new ComponentHelper_1.default()\n                            .addInteractionButton(ComponentHelper_1.default.BUTTON_SUCCESS, `modlogconfig-yes.${msg.author.id}`, false, undefined, \"Configure\")\n                            .addInteractionButton(ComponentHelper_1.default.BUTTON_DANGER, `modlogconfig-no.${msg.author.id}`, false, undefined, \"Defaults\")\n                            .addInteractionButton(ComponentHelper_1.default.BUTTON_PRIMARY, `modlogconfig-cancel.${msg.author.id}`, false, undefined, \"Cancel\")\n                            .toJSON()\n                    });\n                    break;\n                }\n                // provide url\n                case 2: {\n                    const hooks = await msg.channel.guild.getWebhooks();\n                    if (hooks.length === 0)\n                        return m.edit(\"Th-This server doesn't have any webhooks to use..\");\n                    await m.edit(\"Please provide a full webhook url.\");\n                    const wait = await msg.channel.awaitMessages(6e4, ({ author: { id } }) => id === msg.author.id, 1);\n                    if (wait === null)\n                        return m.edit({\n                            content: \"Y-you took too long to respond..\"\n                        });\n                    if (wait.content.toLowerCase() === \"cancel\")\n                        return m.edit(\"Cancelled.\");\n                    const [, id, token] = (/https?:\\/\\/(?:canary\\.|ptb\\.)?discord(?:app)?\\.com\\/api\\/webhooks\\/(\\d{15,21})\\/([a-zA-Z\\d_-]+)/.exec(wait.content) ?? []);\n                    if (!id || !token)\n                        return m.edit(\"The provided webhook url is not valid.\");\n                    const w = hooks.find(v => v.id === id && v.token === v.token);\n                    if (w === undefined)\n                        return m.edit(\"The webhook you provided is either invalid, or not a part of this server.\");\n                    hook = w;\n                    break;\n                }\n                // create\n                case 3: {\n                    if (!ch.permissionsOf(this.user.id).has(\"manageWebhooks\"))\n                        return m.edit(\"I-I'm missing the **Manage Webhooks** permission..\");\n                    const img = await utils_1.Request.getImageFromURL(_config_1.default.images.bot);\n                    const { mime } = await file_type_1.default.fromBuffer(img) ?? { mime: null };\n                    if (mime === null)\n                        throw new Error(\"Internal error.\");\n                    const b64 = Buffer.from(img).toString(\"base64\");\n                    hook = await ch.createWebhook({\n                        name: \"Maid Boye Moderation Log\",\n                        avatar: `data:${mime};base64,${b64}`\n                    });\n                    await sel.editOriginalMessage({\n                        content: `Successfully created the webhook **${hook.name}** (${hook.id})\\nWould you like to configure the more detailed options, or leave them at their defaults?`,\n                        components: new ComponentHelper_1.default()\n                            .addInteractionButton(ComponentHelper_1.default.BUTTON_SUCCESS, `modlogconfig-yes.${msg.author.id}`, false, undefined, \"Configure\")\n                            .addInteractionButton(ComponentHelper_1.default.BUTTON_DANGER, `modlogconfig-no.${msg.author.id}`, false, undefined, \"Defaults\")\n                            .addInteractionButton(ComponentHelper_1.default.BUTTON_PRIMARY, `modlogconfig-cancel.${msg.author.id}`, false, undefined, \"Cancel\")\n                            .toJSON()\n                    });\n                    break;\n                }\n                default: return msg.channel.createMessage(\"There was an internal error..\");\n            }\n            const opt = await configureOptions.call(this, m);\n            if (opt === null)\n                return;\n            opt.webhook = {\n                id: hook.id,\n                token: hook.token,\n                channelId: hook.channel_id\n            };\n            await msg.gConfig.edit({\n                modlog: opt\n            });\n            await this.executeWebhook(opt.webhook.id, opt.webhook.token, {\n                embeds: [\n                    new EmbedBuilder_1.default()\n                        .setTitle(\"Modlog Configured\")\n                        .setDescription(`This channel has been chosen for this servers modlog, by <@!${msg.author.id}>.`, \"\", \"Settings:\", `Case Editing Enabled: **${opt.caseEditingEnabled ? \"Yes\" : \"No\"}**`, `Case Deleting Enabled: **${opt.caseDeletingEnabled ? \"Yes\" : \"No\"}**`, `Edit Others Cases Enabled: **${opt.editOthersCasesEnabled ? \"Yes\" : \"No\"}**`)\n                        .setColor(\"gold\")\n                        .toJSON()\n                ]\n            });\n            await m.edit({\n                content: \"Setup complete.\",\n                embeds: [],\n                components: []\n            });\n            break;\n        }\n        case \"reset\": {\n            if (msg.gConfig.modlog.enabled === false)\n                return m.edit(\"H-hey! The modlog isn't enabled here..\");\n            if (msg.gConfig.modlog.webhook) {\n                const wh = await this.getWebhook(msg.gConfig.modlog.webhook.id, msg.gConfig.modlog.webhook.token).catch(() => null);\n                if (wh !== null) {\n                    await m.edit({\n                        content: `Do you want to delete the associated modlog webhook **${wh.name}** (${wh.id})?`,\n                        components: new ComponentHelper_1.default()\n                            .addInteractionButton(ComponentHelper_1.default.BUTTON_SECONDARY, `delhook-yes.${msg.author.id}`, false, undefined, \"Yes\")\n                            .addInteractionButton(ComponentHelper_1.default.BUTTON_DANGER, `delhook-no.${msg.author.id}`, false, undefined, \"No\")\n                            .addInteractionButton(ComponentHelper_1.default.BUTTON_SUCCESS, `delhook-cancel.${msg.author.id}`, false, undefined, \"Cancel\")\n                            .toJSON()\n                    });\n                    const delHook = await msg.channel.awaitComponentInteractions(6e4, (it) => it.channelID === msg.channel.id && it.message.id === m.id && it.data.custom_id.startsWith(\"delhook\") && it.data.custom_id.endsWith(msg.author.id) && it.member.user.id === msg.author.id);\n                    if (delHook === null)\n                        return m.edit({\n                            content: \"Timeout detected, modlog has not been reset.\",\n                            components: []\n                        });\n                    switch (delHook.data.custom_id.split(\"-\")[1].split(\".\")[0]) {\n                        case \"yes\": {\n                            await this.deleteWebhook(msg.gConfig.modlog.webhook.id, msg.gConfig.modlog.webhook.token, `ModLog Reset: ${msg.author.tag} (${msg.author.id})`).catch(() => null);\n                            await msg.gConfig.edit({\n                                modlog: _config_1.default.defaults.guild.modlog\n                            });\n                            return m.edit({\n                                content: \"The webhook has been deleted, and the modlog was reset.\",\n                                components: []\n                            });\n                            break;\n                        }\n                        case \"no\": {\n                            await msg.gConfig.edit({\n                                modlog: _config_1.default.defaults.guild.modlog\n                            });\n                            return m.edit({\n                                content: \"The webhook was not deleted, and the modlog was reset.\",\n                                components: []\n                            });\n                            break;\n                        }\n                        case \"cancel\": return m.edit({\n                            content: \"Cancelled.\",\n                            components: []\n                        });\n                    }\n                }\n            }\n            await msg.gConfig.edit({\n                modlog: _config_1.default.defaults.guild.modlog\n            });\n            await m.edit({\n                content: \"The modlog has been reset.\",\n                components: []\n            });\n            break;\n        }\n        case \"info\":\n        case \"get\": {\n            if (msg.gConfig.modlog.enabled === false || msg.gConfig.modlog.webhook === null)\n                return m.edit(\"This server's modlog is not enabled.\");\n            const wh = await this.getWebhook(msg.gConfig.modlog.webhook.id, msg.gConfig.modlog.webhook.token);\n            return m.edit({\n                content: \"\",\n                embeds: [\n                    new EmbedBuilder_1.default()\n                        .setTitle(\"ModLog Info\")\n                        .setDescription(`Channel: <#${msg.gConfig.modlog.webhook.channelId}>`, \"\", \"Settings:\", `${_config_1.default.emojis.default.dot} **Case Editing**: ${_config_1.default.emojis.custom[msg.gConfig.modlog.caseEditingEnabled ? \"greenTick\" : \"redTick\"]} ${msg.gConfig.modlog.caseEditingEnabled ? \"Enabled\" : \"Disabled\"}`, `${_config_1.default.emojis.default.dot} **Case Deleting**: ${_config_1.default.emojis.custom[msg.gConfig.modlog.caseDeletingEnabled ? \"greenTick\" : \"redTick\"]} ${msg.gConfig.modlog.caseDeletingEnabled ? \"Enabled\" : \"Disabled\"}`, `${_config_1.default.emojis.default.dot} **Edit Others Cases**: ${_config_1.default.emojis.custom[msg.gConfig.modlog.editOthersCasesEnabled ? \"greenTick\" : \"redTick\"]} ${msg.gConfig.modlog.editOthersCasesEnabled ? \"Enabled\" : \"Disabled\"}`, \"\", \n                    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n                    `Webhook: **${wh.name}** (\\`${wh.id}\\`, [[avatar](${Object.getOwnPropertyDescriptor(eris_1.default.User.prototype, \"avatarURL\").get.call({ _client: this, id: wh.id, avatar: wh.avatar })})])`)\n                        .setColor(\"gold\")\n                        .toJSON()\n                ]\n            });\n            break;\n        }\n        default: return new CommandError_1.default(\"INVALID_USAGE\", cmd);\n    }\n}"
	},
	{
		"mute": "async function (msg, cmd) {\n    if (msg.gConfig.settings.muteRole === null)\n        return msg.reply(`Th-this server's mute role hasn't been set up.. Try \\`${msg.gConfig.getFormattedPrefix()}settings\\``);\n    const r = msg.channel.guild.roles.get(msg.gConfig.settings.muteRole);\n    if (!r) {\n        await msg.gConfig.edit({\n            settings: {\n                muteRole: null\n            }\n        });\n        return msg.reply(\"Th-this server's mute role is invalid..\");\n    }\n    if (msg.args.length < 1)\n        return new CommandError_1.default(\"INVALID_USAGE\", cmd);\n    const nodm = msg.dashedArgs.value.includes(\"nodm\");\n    const member = await msg.getMemberFromArgs();\n    if (member === null)\n        return msg.reply(\"Th-that wasn't a valid member..\");\n    if (member.id === msg.author.id)\n        return msg.reply(\"I-I can't let you do that..\");\n    if (member.id === msg.channel.guild.ownerID)\n        return msg.reply(\"Y-you can't mute the server owner!\");\n    const compare = msg.member.compareToMember(member);\n    if ([\"higher\", \"same\"].includes(compare) && msg.member.id !== msg.channel.guild.ownerID)\n        return msg.reply(\"Th-that user is higher than, or as high as your highest role.. You cannot mute them\");\n    const compareMe = msg.channel.guild.me.compareToMember(member);\n    if ([\"higher\", \"same\"].includes(compareMe))\n        return msg.reply(\"Th-that user is higher than, or as high as my highest role.. I cannot mute them\");\n    if (member.roles.includes(r.id))\n        return msg.reply(\"Th-that member is already muted..\");\n    let time = utils_1.Time.parseTime2(msg.args.slice(1)[msg.args.length - 1]), reason = null;\n    if (msg.args.length !== 1) {\n        if (time === 0) {\n            time = utils_1.Time.parseTime2(msg.args.join(\" \"));\n            reason = msg.args.slice(1).join(\" \");\n        }\n        else\n            reason = msg.args.slice(1, -1).join(\" \");\n        if (time < 1000)\n            time = 0;\n    }\n    if (time > 1.5768e11)\n        return msg.reply(\"H-hey! The maximum time is 5 years!\");\n    if (reason && reason.length > 500)\n        return msg.reply(\"Th-that reason is too long!\");\n    let dmError;\n    let dm = null;\n    if (!nodm && member !== null && !member.bot)\n        dm = await member.user.createMessage(`You were muted in **${msg.channel.guild.name}** by **${msg.author.tag}**\nReason:\\n\\`\\`\\`\\n${reason ?? \"None Provided\"}\\`\\`\\`\\nTime: **${time === 0 ? \"Permanent\" : utils_1.Time.ms(time, true, true, false)}**`)\n            .catch((err) => ((dmError = `${err.name}: ${err.message}`, null)));\n    await member.addRole(r.id, `Mute: ${msg.author.tag} (${msg.author.id}) -> ${reason ?? \"None Provided\"}`)\n        .catch(async (err) => {\n        if (dm !== null)\n            await dm.delete().catch(() => null);\n        return msg.channel.createMessage(`I-I failed to mute **${member.tag}**..\\n\\`${err.name}: ${err.message}\\``);\n    })\n        .then(async () => {\n        if (member.voiceState.channelID !== null) {\n            try {\n                await member.edit({ mute: true }, `Mute: ${msg.author.tag} (${msg.author.id}) -> ${reason ?? \"None Provided\"}`);\n            }\n            catch {\n                // they need to be in a voice channel for this to work\n            }\n        }\n        const mdl = await ModLogHandler_1.default.createMuteEntry(msg.gConfig, member, msg.author, reason, time);\n        return msg.channel.createMessage(`**${member.tag}** was muted ${time === 0 ? \"permanently\" : `for \\`${utils_1.Time.ms(time, true, true, false)}\\``}, ***${reason ?? \"None Provided\"}***${dmError !== undefined ? `\\n\\nFailed to send dm:\\n\\`${dmError}\\`` : \"\"}${mdl.check !== false ? `\\nFor more info, check <#${msg.gConfig.modlog.webhook.channelId}> (case: **#${mdl.entryId}**)` : \"\"}`);\n    });\n}"
	},
	{
		"reason": "async function (msg, cmd) {\n    const check = await ModLogHandler_1.default.check(msg.gConfig);\n    if (check === false)\n        return msg.reply(\"Th-the modlog isn't enabled here..\");\n    if (msg.gConfig.modlog.caseEditingEnabled === false)\n        return msg.reply(\"Case editing is disabled.\");\n    if (msg.args.length < 2)\n        return new CommandError_1.default(\"INVALID_USAGE\", cmd);\n    const n = Number(msg.args[0]);\n    const reason = msg.args.slice(1).join(\" \");\n    if (isNaN(n) || n < 1)\n        return msg.reply(\"Th-that wasn't a valid case number..\");\n    const c = await msg.gConfig.getModlogEntry(n);\n    if (c === null)\n        return msg.reply(`I-I couldn't find a case with the number **${n}**..`);\n    if (msg.gConfig.modlog.editOthersCasesEnabled === false && c.blame !== msg.author.id)\n        return msg.reply(\"H-hey! That isn't your case, and **Edit Others Cases** isn't enabled..\");\n    const m = await c.getMessage(this);\n    if (c.reason === reason && !msg.dashedArgs.value.includes(\"force\"))\n        return msg.reply(\"Th-that's the same reason as the current one.. If you want to force an update, add `--force` to the end of the commnd.\");\n    if (reason && reason.length > 500)\n        return msg.reply(\"Th-that reason is too long!\");\n    let editError = false;\n    if (m !== null) {\n        const e = new EmbedBuilder_1.default(false, undefined, m.embeds[0]);\n        e.setDescription(e.getDescription().split(\"\n\").map(d => {\n            if (d.startsWith(\"Reason\"))\n                return `Reason: **${reason}**`;\n            if (d.startsWith(\"Last Edit\"))\n                return `Last Edit: by **${msg.author.tag}** on ${BotFunctions_1.default.formatDiscordTime(Date.now(), \"short-datetime\", true)}`;\n            return d;\n        }), e.getDescription().includes(\"Last Edit\") ? \"\" : `Last Edit: by **${msg.author.tag}** on ${BotFunctions_1.default.formatDiscordTime(Date.now(), \"short-datetime\", true)}`);\n        await m.editWebhook(msg.gConfig.modlog.webhook.token, {\n            embeds: [\n                e.toJSON()\n            ]\n        }).catch((err) => {\n            Logger_1.default.getLogger(\"ReasonCommand\").error(err);\n            editError = true;\n        });\n    }\n    else\n        editError = true;\n    await c.edit(reason, msg.author.id);\n    if (editError === true)\n        return msg.reply(\"We failed to fetch the modlog message, so the case has only been updated on our side.\");\n    else\n        return msg.reply(\"Case successfully updated.\");\n}"
	},
	{
		"setup-mutes": "async function (msg) {\n    if (msg.gConfig.settings.muteRole === null)\n        return msg.reply(`Th-this server's mute role hasn't been set up.. Try \\`${msg.gConfig.getFormattedPrefix()}settings\\``);\n    const r = msg.channel.guild.roles.get(msg.gConfig.settings.muteRole);\n    if (!r) {\n        await msg.gConfig.edit({\n            settings: {\n                muteRole: null\n            }\n        });\n        return msg.reply(\"Th-this server's mute role is invalid..\");\n    }\n    const permsText = {};\n    const permsVoice = {};\n    msg.channel.guild.channels.forEach(ch => {\n        const everyone = ch.permissionOverwrites.get(msg.channel.guild.id);\n        const role = ch.permissionOverwrites.get(msg.gConfig.settings.muteRole);\n        const t = {};\n        const v = {};\n        // text\n        if (ch.type === eris_1.default.Constants.ChannelTypes.GUILD_TEXT || ch.type === eris_1.default.Constants.ChannelTypes.GUILD_NEWS) {\n            if (everyone && everyone.allow & eris_1.default.Constants.Permissions.sendMessages)\n                t[everyone.id] = [everyone.allow - eris_1.default.Constants.Permissions.sendMessages, everyone.deny];\n            if (role && role.allow & eris_1.default.Constants.Permissions.sendMessages)\n                t[role.id] = [role.allow - eris_1.default.Constants.Permissions.sendMessages, role.deny];\n            if (role && !(role.deny & eris_1.default.Constants.Permissions.sendMessages))\n                t[role.id] = [!t[role.id] ? role.allow : t[role.id][0], role.deny | eris_1.default.Constants.Permissions.sendMessages];\n            if (!role || role?.deny === 0n)\n                t[msg.gConfig.settings.muteRole] = [!t[msg.gConfig.settings.muteRole] ? 0n : t[msg.gConfig.settings.muteRole][0], eris_1.default.Constants.Permissions.sendMessages];\n            if (Object.keys(t).length !== 0)\n                permsText[ch.id] = t;\n            // voice\n        }\n        else if (ch.type === eris_1.default.Constants.ChannelTypes.GUILD_VOICE) {\n            if (everyone && everyone.allow & eris_1.default.Constants.Permissions.voiceSpeak)\n                v[everyone.id] = [everyone.allow - eris_1.default.Constants.Permissions.voiceSpeak, everyone.deny];\n            if (role && role.allow & eris_1.default.Constants.Permissions.voiceSpeak)\n                v[role.id] = [role.allow - eris_1.default.Constants.Permissions.voiceSpeak, role.deny];\n            if (role && !(role.deny & eris_1.default.Constants.Permissions.voiceSpeak))\n                v[role.id] = [!v[role.id] ? role.allow : v[role.id][0], role.deny | eris_1.default.Constants.Permissions.voiceSpeak];\n            if (!role || role?.deny === 0n)\n                v[msg.gConfig.settings.muteRole] = [!v[msg.gConfig.settings.muteRole] ? 0n : v[msg.gConfig.settings.muteRole][0], eris_1.default.Constants.Permissions.voiceSpeak];\n            if (Object.keys(v).length !== 0)\n                permsVoice[ch.id] = v;\n        }\n        else\n            return;\n    });\n    if (Object.keys(permsText).length === 0 && Object.keys(permsVoice).length === 0)\n        return msg.reply(\"Mutes seem to already be set up?\");\n    const m = await msg.reply({\n        embeds: [\n            new EmbedBuilder_1.default(true, msg.author)\n                .setTitle(\"Confirm Edits\")\n                .setDescription(`Are you sure you want to edit **${Object.keys(permsText).length}** text channel${Object.keys(permsText).length !== 1 ? \"s\" : \"\"} and **${Object.keys(permsVoice).length}** voice channel${Object.keys(permsVoice).length !== 1 ? \"s\" : \"\"}?`)\n                .toJSON()\n        ],\n        components: new ComponentHelper_1.default()\n            .addInteractionButton(ComponentHelper_1.default.BUTTON_SECONDARY, `confirmmutes-yes.${msg.author.id}`, false, undefined, \"Yes\")\n            .addInteractionButton(ComponentHelper_1.default.BUTTON_DANGER, `confirmmutes-no.${msg.author.id}`, false, undefined, \"No\")\n            .toJSON()\n    });\n    const w = await msg.channel.awaitComponentInteractions(3e4, (it) => it.data.custom_id.startsWith(\"confirmmutes-\") && it.member.user.id === msg.author.id && it.message.id === m.id);\n    if (w === null)\n        return m.edit({\n            embeds: [\n                new EmbedBuilder_1.default(true, msg.author)\n                    .setTitle(\"Edits Cancelled\")\n                    .setColor(\"red\")\n                    .setDescription(\"Timeout detected, cancelling.\")\n                    .toJSON()\n            ],\n            components: []\n        });\n    if (w.data.custom_id.includes(\"no\"))\n        return w.createMessage({\n            embeds: [\n                new EmbedBuilder_1.default(true, msg.author)\n                    .setTitle(\"Edits Cancelled\")\n                    .setColor(\"red\")\n                    .setDescription(\"Cancelled.\")\n                    .toJSON()\n            ],\n            components: []\n        });\n    await w.createMessage({\n        content: \"Processing..\",\n        embeds: [],\n        components: []\n    });\n    await msg.channel.sendTyping();\n    const t = setInterval(() => msg.channel.sendTyping(), 7e3);\n    let errorCount = 0;\n    try {\n        await Promise.all([...Object.entries(permsText), ...Object.entries(permsVoice)].map(async ([channelId, p]) => {\n            const k = Object.entries(p);\n            for (const [id, [allow, deny]] of k) {\n                const ch = msg.channel.guild.channels.get(channelId);\n                if (ch === undefined) {\n                    errorCount++;\n                    continue;\n                }\n                await ch.editPermission(id, allow, deny, 0, `Setup-Mutes: ${msg.author.tag} (${msg.author.id})`).catch((err) => {\n                    Logger_1.default.getLogger(\"SetupMutesCommand\").error(err);\n                    errorCount++;\n                });\n            }\n        }));\n    }\n    catch (e) {\n        clearInterval(t);\n        throw e;\n    }\n    clearInterval(t);\n    await m.edit(`Completed with **${errorCount}** error${errorCount !== 1 ? \"s\" : \"\"}.`);\n}"
	},
	{
		"softban": "async function (msg, cmd) {\n    if (msg.args.length < 1)\n        return new CommandError_1.default(\"INVALID_USAGE\", cmd);\n    const nodm = msg.dashedArgs.value.includes(\"nodm\");\n    let delDays = Number(msg.dashedArgs.keyValue.deldays);\n    if (isNaN(delDays))\n        delDays = 1;\n    const member = await msg.getMemberFromArgs();\n    if (member === null)\n        return msg.reply(\"Th-that wasn't a valid member..\");\n    if (member.id === msg.author.id)\n        return msg.reply(\"I-I can't let you do that..\");\n    if (member.id === msg.channel.guild.ownerID)\n        return msg.reply(\"Y-you can't softban the server owner!\");\n    const compare = msg.member.compareToMember(member);\n    if ([\"higher\", \"same\"].includes(compare) && msg.member.id !== msg.channel.guild.ownerID)\n        return msg.reply(\"Th-that user is higher than, or as high as your highest role.. You cannot softban them\");\n    const compareMe = msg.channel.guild.me.compareToMember(member);\n    if ([\"higher\", \"same\"].includes(compareMe))\n        return msg.reply(\"Th-that user is higher than, or as high as my highest role.. I cannot softban them\");\n    const reason = msg.args.length === 1 ? null : msg.args.slice(1).join(\" \");\n    if (reason && reason.length > 500)\n        return msg.reply(\"Th-that reason is too long!\");\n    let dmError;\n    let dm = null;\n    if (!nodm && member !== null && !member.bot)\n        dm = await member.user.createMessage(`You were softbanned from **${msg.channel.guild.name}** by **${msg.author.tag}**\nReason:\\n\\`\\`\\`\\n${reason ?? \"None Provided\"}\\`\\`\\`\\nWe are not responsible for inviting you back, contact a server staff member.`)\n            .catch((err) => ((dmError = `${err.name}: ${err.message}`, null)));\n    await member.ban(delDays, `SoftBan: ${msg.author.tag} (${msg.author.id}) -> ${reason ?? \"None Provided\"}`)\n        // catch first so we only catch an error from ban\n        .catch(async (err) => {\n        // delete the dm if we didn't ban them\n        if (dm !== null)\n            await dm.delete().catch(() => null);\n        return msg.channel.createMessage(`I-I failed to ban **${member.tag}**..\\n\\`${err.name}: ${err.message}\\``);\n    })\n        .then(async () => {\n        await member.unban(`SoftBan: ${msg.author.tag} (${msg.author.id}) -> ${reason ?? \"None Provided\"}`);\n    })\n        .catch(async (err) => msg.channel.createMessage(`I-I failed to unban **${member.tag}**..\\n\\`${err.name}: ${err.message}\\``))\n        .then(async () => {\n        const mdl = await ModLogHandler_1.default.createSoftBanEntry(msg.gConfig, member, msg.author, reason, delDays);\n        return msg.channel.createMessage(`**${member.tag}** was softbanned, ***${reason ?? \"None Provided\"}***${dmError !== undefined ? `\\n\\nFailed to send dm:\\n\\`${dmError}\\`` : \"\"}${mdl.check !== false ? `\\nFor more info, check <#${msg.gConfig.modlog.webhook.channelId}> (case: **#${mdl.entryId}**)` : \"\"}`);\n    });\n}"
	},
	{
		"strike": "async function (msg) {\n    const member = await msg.getMemberFromArgs();\n    const amount = msg.args.length === 1 ? 1 : Number(msg.args[1]);\n    if (member === null)\n        return msg.reply(\"Th-that wasn't a valid member..\");\n    if (member.id === msg.author.id)\n        return msg.reply(\"H-hey! You can't strike yourself!\");\n    const c = msg.member.compareToMember(member);\n    if (c !== \"lower\")\n        return msg.reply(\"H-hey! You can't strike people higher than you!\");\n    if (amount < 1)\n        return msg.reply(\"Y-you have to add at least one strike..\");\n    if (amount > 10 && !_config_1.default.developers.includes(msg.author.id))\n        return msg.reply(\"Y-you cannot add more than 10 strikes at a time..\");\n    await _db_1.default.createUserIfNotExists(member.id);\n    await UserConfig_1.default.prototype.addStrikes.call({\n        id: member.id\n    }, msg.channel.guild.id, msg.author.id, amount);\n    const count = await UserConfig_1.default.prototype.getStrikeCount.call({\n        id: member.id\n    }, msg.channel.guild.id);\n    return msg.reply({\n        content: `Successfully added **${amount}** strike${amount !== 1 ? \"s\" : \"\"} to <@!${member.id}>, they now have **${count}** strike${count !== 1 ? \"s\" : \"\"}`,\n        allowedMentions: {\n            users: false\n        }\n    });\n}"
	},
	{
		"unban": "async function (msg, cmd) {\n    if (msg.args.length < 1)\n        return new CommandError_1.default(\"INVALID_USAGE\", cmd);\n    const nodm = msg.dashedArgs.value.includes(\"nodm\");\n    let delDays = Number(msg.dashedArgs.keyValue.deldays);\n    if (isNaN(delDays))\n        delDays = 1;\n    const member = await msg.getMemberFromArgs();\n    if (member === null)\n        return msg.reply(\"Th-that wasn't a valid member..\");\n    if (member.id === msg.author.id)\n        return msg.reply(\"I-I can't let you do that..\");\n    if (member.id === msg.channel.guild.ownerID)\n        return msg.reply(\"Y-you can't softban the server owner!\");\n    const compare = msg.member.compareToMember(member);\n    if ([\"higher\", \"same\"].includes(compare) && msg.member.id !== msg.channel.guild.ownerID)\n        return msg.reply(\"Th-that user is higher than, or as high as your highest role.. You cannot softban them\");\n    const compareMe = msg.channel.guild.me.compareToMember(member);\n    if ([\"higher\", \"same\"].includes(compareMe))\n        return msg.reply(\"Th-that user is higher than, or as high as my highest role.. I cannot softban them\");\n    const reason = msg.args.length === 1 ? null : msg.args.slice(1).join(\" \");\n    if (reason && reason.length > 500)\n        return msg.reply(\"Th-that reason is too long!\");\n    let dmError;\n    let dm = null;\n    if (!nodm && member !== null && !member.bot)\n        dm = await member.user.createMessage(`You were softbanned from **${msg.channel.guild.name}** by **${msg.author.tag}**\nReason:\\n\\`\\`\\`\\n${reason ?? \"None Provided\"}\\`\\`\\`\\nWe are not responsible for inviting you back, contact a server staff member.`)\n            .catch((err) => ((dmError = `${err.name}: ${err.message}`, null)));\n    await member.ban(delDays, `SoftBan: ${msg.author.tag} (${msg.author.id}) -> ${reason ?? \"None Provided\"}`)\n        // catch first so we only catch an error from ban\n        .catch(async (err) => {\n        // delete the dm if we didn't ban them\n        if (dm !== null)\n            await dm.delete().catch(() => null);\n        return msg.channel.createMessage(`I-I failed to ban **${member.tag}**..\\n\\`${err.name}: ${err.message}\\``);\n    })\n        .then(async () => {\n        await member.unban(`SoftBan: ${msg.author.tag} (${msg.author.id}) -> ${reason ?? \"None Provided\"}`);\n    })\n        .catch(async (err) => msg.channel.createMessage(`I-I failed to unban **${member.tag}**..\\n\\`${err.name}: ${err.message}\\``))\n        .then(async () => {\n        const mdl = await ModLogHandler_1.default.createSoftBanEntry(msg.gConfig, member, msg.author, reason, delDays);\n        return msg.channel.createMessage(`**${member.tag}** was softbanned, ***${reason ?? \"None Provided\"}***${dmError !== undefined ? `\\n\\nFailed to send dm:\\n\\`${dmError}\\`` : \"\"}${mdl.check !== false ? `\\nFor more info, check <#${msg.gConfig.modlog.webhook.channelId}> (case: **#${mdl.entryId}**)` : \"\"}`);\n    });\n}"
	},
	{
		"unlock": "async function (msg) {\n    const ch = (msg.args.length === 0 ? msg.channel : await msg.getChannelFromArgs());\n    if (ch === null)\n        return msg.reply(\"Th-that wasn't a valid channel..\");\n    // guild id = @everyone\n    const o = ch.permissionOverwrites.get(msg.channel.guild.id);\n    if (o) {\n        if (o.allow & eris_1.default.Constants.Permissions.sendMessages || !(o.deny & eris_1.default.Constants.Permissions.sendMessages))\n            return msg.reply(\"Th-that channel doesn't seem to be locked?\");\n        if (o.deny & eris_1.default.Constants.Permissions.sendMessages)\n            o.deny -= eris_1.default.Constants.Permissions.sendMessages;\n    }\n    const reason = msg.args.length < 2 ? null : msg.args.slice(1).join(\" \");\n    if (reason && reason.length > 500)\n        return msg.reply(\"Th-that reason is too long!\");\n    await ch.editPermission(msg.channel.guild.id, o?.allow ?? 0n, o?.deny ?? 0n, 0, `Unlock: ${msg.author.tag} (${msg.author.id}) -> ${reason ?? \"None Provided\"}`);\n    const mdl = await ModLogHandler_1.default.createUnLockEntry(msg.gConfig, ch, msg.member, reason);\n    await msg.reply(`Done.${mdl.check === false ? \"\" : ` (case #${mdl.entryId})`}`);\n}"
	},
	{
		"unlockdown": "async function (msg) {\n    const info = await Redis.get(`lockdown:${msg.channel.guild.id}`);\n    if (info === null)\n        return msg.reply(\"Th-this server isn't locked down..\");\n    const channels = msg.channel.guild.channels.filter(c => [eris_1.default.Constants.ChannelTypes.GUILD_TEXT, eris_1.default.Constants.ChannelTypes.GUILD_NEWS].includes(c.type));\n    let pInfo;\n    try {\n        pInfo = JSON.parse(info);\n    }\n    catch {\n        await Redis.del(`lockdown:${msg.channel.guild.id}`);\n        return msg.reply(\"Th-there was an error parsing the lockdown info..\");\n    }\n    const reason = msg.args.join(\" \") || null;\n    if (reason && reason.length > 500)\n        return msg.reply(\"Th-that reason is too long!\");\n    const m = await msg.reply(\"Running..\");\n    let i = 0;\n    for (const ch of channels) {\n        const o = pInfo.find(([v]) => v === ch.id);\n        const p = ch.permissionOverwrites.get(msg.channel.guild.id);\n        if (!o || !p)\n            continue;\n        i++;\n        if (p.allow & eris_1.default.Constants.Permissions.sendMessages)\n            p.allow -= eris_1.default.Constants.Permissions.sendMessages;\n        await ch.editPermission(msg.channel.guild.id, BigInt(o[1]), BigInt(o[2]), 0, `Unlockdown: ${msg.author.tag} (${msg.author.id}) -> ${reason ?? \"None Provided\"}`);\n    }\n    await Redis.del(`lockdown:${msg.channel.guild.id}`);\n    const mdl = await ModLogHandler_1.default.createUnLockDownEntry(msg.gConfig, msg.member, reason);\n    await m.edit(`Unlocked **${i}** channel${i !== 1 ? \"s\" : \"\"}. ${mdl.check === false ? \"\" : ` (case #${mdl.entryId})`}`);\n}"
	},
	{
		"unmute": "async function (msg, cmd) {\n    if (msg.gConfig.settings.muteRole === null)\n        return msg.reply(`Th-this server's mute role hasn't been set up.. Try \\`${msg.gConfig.getFormattedPrefix()}settings\\``);\n    const r = msg.channel.guild.roles.get(msg.gConfig.settings.muteRole);\n    if (!r) {\n        await msg.gConfig.edit({\n            settings: {\n                muteRole: null\n            }\n        });\n        return msg.reply(\"Th-this server's mute role is invalid..\");\n    }\n    if (msg.args.length < 1)\n        return new CommandError_1.default(\"INVALID_USAGE\", cmd);\n    const member = await msg.getMemberFromArgs();\n    if (member === null)\n        return msg.reply(\"Th-that wasn't a valid member..\");\n    if (member.id === msg.author.id)\n        return msg.reply(\"I-I can't let you do that..\");\n    const compareMe = msg.channel.guild.me.compareToMember(member);\n    if ([\"higher\", \"same\"].includes(compareMe))\n        return msg.reply(\"Th-that user is higher than, or as high as my highest role.. I cannot unmute them\");\n    if (!member.roles.includes(r.id))\n        return msg.reply(\"Th-that member is not muted..\");\n    const reason = msg.args.length === 1 ? null : msg.args.slice(1).join(\" \");\n    if (reason && reason.length > 500)\n        return msg.reply(\"Th-that reason is too long!\");\n    await member.removeRole(r.id, `Unmute: ${msg.author.tag} (${msg.author.id}) -> ${reason ?? \"None Provided\"}`)\n        .catch(async (err) => msg.channel.createMessage(`I-I failed to unmute **${member.tag}**..\n\\`${err.name}: ${err.message}\\``))\n        .then(async () => {\n        if (member.voiceState.channelID !== null) {\n            try {\n                await member.edit({ mute: false }, `Unmute: ${msg.author.tag} (${msg.author.id}) -> ${reason ?? \"None Provided\"}`);\n            }\n            catch {\n                // they need to be in a voice channel for this to work\n            }\n        }\n        const mdl = await ModLogHandler_1.default.createUnMuteEntry(msg.gConfig, member, msg.author, reason);\n        return msg.channel.createMessage(`**${member.tag}** was unmuted, ***${reason ?? \"None Provided\"}***${mdl.check !== false ? `\\nFor more info, check <#${msg.gConfig.modlog.webhook.channelId}> (case: **#${mdl.entryId}**)` : \"\"}`);\n    });\n}"
	},
	{
		"warn": "async function (msg, cmd) {\n    if (msg.args.length < 1)\n        return new CommandError_1.default(\"INVALID_USAGE\", cmd);\n    const member = await msg.getMemberFromArgs();\n    if (member === null)\n        return msg.reply(\"Th-that wasn't a valid member..\");\n    if (member.id === msg.author.id)\n        return msg.reply(\"I-I can't let you do that..\");\n    if (member.id === msg.channel.guild.ownerID)\n        return msg.reply(\"Y-you can't warn the server owner!\");\n    const compare = msg.member.compareToMember(member);\n    if ([\"higher\", \"same\"].includes(compare) && msg.member.id !== msg.channel.guild.ownerID)\n        return msg.reply(\"Th-that user is higher than, or as high as your highest role.. You warn mute them\");\n    const reason = msg.args.length === 1 ? null : msg.args.slice(1).join(\" \");\n    if (reason && reason.length > 500)\n        return msg.reply(\"Th-that reason is too long!\");\n    const current = await UserConfig_1.default.prototype.getWarningCount.call({ id: member.id }, msg.channel.guild.id);\n    if (current > 100)\n        return msg.reply(\"H-hey! That user has the maimum amount of warnings!\");\n    const w = await UserConfig_1.default.prototype.addWarning.call({ id: member.id }, msg.channel.guild.id, msg.author.id, reason);\n    const mdl = await ModLogHandler_1.default.createWarnEntry(msg.gConfig, member, msg.author, reason, w);\n    return msg.reply(`**${member.tag}** was warned, ***${reason ?? \"None Provided\"}***${mdl.check !== false ? `\nFor more info, check <#${msg.gConfig.modlog.webhook.channelId}> (case: **#${mdl.entryId}**)` : \"\"}`);\n}"
	},
	{
		"bulge": "async function (msg) {\n    let m;\n    async function refreshImage(id, token) {\n        const y = await Yiffy_1.default.furry.bulge(\"json\", 1);\n        const e = new EmbedBuilder_1.default()\n            .setTitle(\"Bolgy Wolgy UwU\")\n            // url buttons\n            /* .setDescription(\n                `[[Short URL]](${y.shortURL})`,\n                `[[Report]](${y.reportURL})`,\n                `${y.sources.length === 0 ? \"[No Source]\" : `[[Source]](${y.sources[0]})`}`\n            ) */\n            .setImage(y.url)\n            .setColor(\"gold\")\n            .toJSON();\n        const c = new ComponentHelper_1.default()\n            .addURLButton(y.shortURL, false, undefined, \"Full Image\")\n            .addURLButton(y.sources[0] || \"https://yiff.rest\", y.sources.length === 0, undefined, \"Source\")\n            .addURLButton(y.reportURL, false, undefined, \"Report\")\n            .addRow()\n            .addInteractionButton(ComponentHelper_1.default.BUTTON_SECONDARY, `new-image.${msg.author.id}`, false, undefined, \"New Image\")\n            .toJSON();\n        if (m === undefined)\n            m = await msg.reply({\n                embeds: [e],\n                components: c\n            });\n        else {\n            if (!id || !token)\n                return;\n            await this.createInteractionResponse(id, token, {\n                type: eris_1.default.Constants.InteractionResponseTypes.UPDATE_MESSAGE,\n                data: {\n                    embeds: [e],\n                    components: c\n                }\n            });\n        }\n        const wait = await msg.channel.awaitComponentInteractions(3e5, (it) => it.channelID === msg.channel.id && it.message.id === m.id && it.data.custom_id.startsWith(\"new-image\") && it.data.custom_id.endsWith(msg.author.id) && it.member.user.id === msg.author.id);\n        if (wait === null) {\n            await m.edit({\n                content: m.content,\n                embeds: m.embeds,\n                components: m.components?.slice(0, 1)\n            });\n            clearTimeout(t);\n        }\n        else\n            return refreshImage.call(this, wait.id, wait.token);\n    }\n    await refreshImage.call(this);\n    const t = setTimeout(() => {\n        if (m !== undefined)\n            void m.edit({\n                content: m.content,\n                embeds: m.embeds,\n                components: m.components?.slice(0, 1)\n            });\n    }, 9e5);\n}"
	},
	{
		"e621": "async function (msg) {\n    const tags = Array.from(msg.rawArgs).map(t => t.toLowerCase());\n    if (!tags.find(t => t.includes(\"order:\")))\n        tags.push(\"order:favcount\");\n    if ([\"cub\", \"young\"].some(v => tags.includes(v)))\n        return msg.reply(\"H-hey! You tried using a blacklisted tag, don't do that!\");\n    const posts = await E621_1.default.getPosts(tags, 100);\n    /* for (const p of posts) {\n        if (msg.dashedArgs.value.includes(\"no-video\") && p.file.ext === \"webm\") posts.splice(posts.indexOf(p), 1);\n        else if (msg.dashedArgs.value.includes(\"no-flash\") && p.file.ext === \"swf\") posts.splice(posts.indexOf(p), 1);\n    } */\n    let m, i = 0;\n    async function changePost(id, token) {\n        const post = posts[i];\n        const e = new EmbedBuilder_1.default()\n            .setTitle(`E621 | Tags: ${msg.rawArgs.length === 0 ? \"None\" : `\"${msg.rawArgs.join(\" \").slice(0, 500)}\"`}`)\n            .setColor(post.rating === \"s\" ? \"green\" : post.rating === \"q\" ? \"gold\" : post.rating === \"e\" ? \"red\" : \"bot\")\n            .setFooter(`Post #${post.id} | ${i + 1}/${posts.length} | ${post.score.up} ${_config_1.default.emojis.default.up} ${post.score.down} ${_config_1.default.emojis.default.down} | ${post.fav_count} ${_config_1.default.emojis.default.heart}`)\n            .removeDescription();\n        if (id && token)\n            await this.createInteractionResponse(id, token, { type: eris_1.default.Constants.InteractionResponseTypes.DEFERRED_UPDATE_MESSAGE });\n        if (post.tags.general.includes(\"young\")) {\n            posts.splice(i, 1);\n            return changePost.call(this, undefined, token);\n        }\n        if (post.file.ext === \"swf\") {\n            if (msg.dashedArgs.value.includes(\"no-flash\")) {\n                posts.splice(i, 1);\n                return changePost.call(this, undefined, token);\n            }\n            e.setDescription(`This post is a flash animation. Please view it [directly](https://e621.net/posts/${post.id}) on e621.`);\n        }\n        else if (post.file.ext === \"webm\") {\n            if (msg.dashedArgs.value.includes(\"no-video\")) {\n                posts.splice(i, 1);\n                return changePost.call(this, undefined, token);\n            }\n            e.setDescription(`This post is a video. Please view it [directly](https://e621.net/posts/${post.id}) on e621.`);\n            if (msg.gConfig.settings.e621ThumbnailType !== \"none\") {\n                let url = \"https://http.cat/500\";\n                try {\n                    // @FIXME change this if original methods get added\n                    if (token && m)\n                        await this.editWebhookMessage(this.user.id, token, \"@original\", {\n                            embeds: [\n                                new EmbedBuilder_1.default(true, undefined, m.embeds[0])\n                                    .setDescription(\"Generating post preview..\")\n                                    .setImage(\"https://assets.maid.gay/loading.gif\")\n                                    .toJSON()\n                            ],\n                            components: m.components\n                        });\n                    const b = await node_fetch_1.default(\"https://v2.yiff.rest/e621-thumb/create\", {\n                        method: \"POST\",\n                        headers: {\n                            \"User-Agent\": _config_1.default.userAgent,\n                            \"Authorization\": _config_1.default.apiKeys.e621Thumb,\n                            \"Content-Type\": \"application/json\"\n                        },\n                        body: JSON.stringify({\n                            type: msg.gConfig.settings.e621ThumbnailType || \"image\",\n                            url: post.file.url,\n                            length: 2.5\n                        })\n                    }).then((v) => v.json());\n                    url = b.data.url;\n                    if (_config_1.default.developers.includes(msg.author.id)) {\n                        console.log(\"Start Time:\", b.data.startTime || \"Cached\");\n                        console.log(\"End Time:\", b.data.endTime || \"Cached\");\n                        if (b.data.createTime === null)\n                            console.log(\"Create Time: Cached\");\n                        else {\n                            console.log(\"Create Time:\");\n                            console.log(`Total Time: ${b.data.createTime.total}ms (${b.data.createTime.totalNs}ns)`);\n                            console.log(`Upload Time: ${b.data.createTime.upload}ms (${b.data.createTime.uploadNs}ns)`);\n                            console.log(`Cut Time: ${b.data.createTime.cut}ms (${b.data.createTime.cutNs}ns)`);\n                            console.log(`Get VTG Time: ${b.data.createTime.getVTG}ms (${b.data.createTime.getVTGNs}ns)`);\n                            console.log(`Convert Time: ${b.data.createTime.convert}ms (${b.data.createTime.convertNs}ns)`);\n                        }\n                    }\n                }\n                catch (err) {\n                    Logger_1.default.getLogger(\"E621Command\").error(`Error creating webm thumbnail (https://e621.net/posts/${post.id})`);\n                    console.error(err);\n                }\n                e.setImage(url);\n            }\n        }\n        else\n            e.setImage(post.file.url);\n        e.setDescription(e.getDescription(), \"(post numbers may fluctuate as we filter things)\");\n        let a;\n        if (post.tags.artist.length === 0)\n            a = \"unknown_artist\";\n        else if (post.tags.artist.length === 1)\n            a = post.tags.artist[0];\n        else\n            a = post.tags.artist.find(v => ![\"conditional_dnp\", \"sound_warning\"].includes(v)) || \"unknown_artist\";\n        const c = new ComponentHelper_1.default()\n            .addURLButton(`https://e621.net/posts/${post.id}`, false, undefined, \"Open Post\")\n            .addURLButton(post.file.url, false, undefined, \"Full Image\")\n            .addURLButton(post.sources[0] || `https://e621.net/${post.id}`, post.sources.length === 0, undefined, \"Source\")\n            .addURLButton(`https://e621.net/artists/show_or_new?name=${a}`, false, undefined, `Artist: ${a}`)\n            .addInteractionButton(post.rating === \"s\" ? ComponentHelper_1.default.BUTTON_SECONDARY :\n            post.rating === \"q\" ? ComponentHelper_1.default.BUTTON_PRIMARY :\n                post.rating === \"e\" ? ComponentHelper_1.default.BUTTON_DANGER :\n                    ComponentHelper_1.default.BUTTON_SUCCESS, `e621-rating.${msg.author.id}`, true, undefined, `Rating: ${post.rating === \"s\" ? \"Safe\" : post.rating === \"q\" ? \"Questionable\" : post.rating === \"e\" ? \"Explicit\" : \"Unknown\"}`)\n            .addRow()\n            .addInteractionButton(ComponentHelper_1.default.BUTTON_SECONDARY, `e621-first.${msg.author.id}`, i === 0, ComponentHelper_1.default.emojiToPartial(_config_1.default.emojis.default.first, \"default\"), \"First\")\n            .addInteractionButton(ComponentHelper_1.default.BUTTON_SECONDARY, `e621-back.${msg.author.id}`, false, ComponentHelper_1.default.emojiToPartial(_config_1.default.emojis.default.back, \"default\"), \"Back\")\n            .addInteractionButton(ComponentHelper_1.default.BUTTON_SECONDARY, `e621-stop.${msg.author.id}`, false, ComponentHelper_1.default.emojiToPartial(_config_1.default.emojis.default.stop, \"default\"), \"Stop\")\n            .addInteractionButton(ComponentHelper_1.default.BUTTON_SECONDARY, `e621-next.${msg.author.id}`, false, ComponentHelper_1.default.emojiToPartial(_config_1.default.emojis.default.next, \"default\"), \"Next\")\n            .addInteractionButton(ComponentHelper_1.default.BUTTON_SECONDARY, `e621-last.${msg.author.id}`, i === (posts.length - 1), ComponentHelper_1.default.emojiToPartial(_config_1.default.emojis.default.last, \"default\"), \"Last\")\n            .toJSON();\n        if (m === undefined)\n            m = await msg.reply({\n                embeds: [e.toJSON()],\n                components: c\n            });\n        else {\n            if (!token)\n                return;\n            // @FIXME change this if original methods get added\n            await this.editWebhookMessage(this.user.id, token, \"@original\", {\n                embeds: [e.toJSON()],\n                components: c\n            });\n        }\n        const wait = await msg.channel.awaitComponentInteractions(3e5, (it) => it.channelID === msg.channel.id && it.message.id === m.id && it.data.custom_id.startsWith(\"e621-\") && it.data.custom_id.endsWith(msg.author.id) && it.member.user.id === msg.author.id);\n        if (wait === null) {\n            await m.edit({\n                embeds: m.embeds,\n                components: m.components?.slice(0, 1)\n            });\n            clearTimeout(t);\n            i = -1;\n        }\n        else {\n            if (wait.data.custom_id.includes(\"first\"))\n                i = 0;\n            if (wait.data.custom_id.includes(\"back\"))\n                i--;\n            if (wait.data.custom_id.includes(\"stop\")) {\n                i = -1;\n                await m.edit({\n                    embeds: m.embeds,\n                    components: m.components?.slice(0, 1)\n                });\n                if (t)\n                    clearTimeout(t);\n                return;\n            }\n            if (wait.data.custom_id.includes(\"next\"))\n                i++;\n            if (wait.data.custom_id.includes(\"last\"))\n                i = posts.length - 1;\n            if (i === -1)\n                return;\n            return changePost.call(this, wait.id, wait.token);\n        }\n    }\n    void changePost.call(this);\n    const t = setTimeout(() => {\n        if (m !== undefined)\n            void m.edit({\n                embeds: m.embeds,\n                components: m.components?.slice(0, 1)\n            });\n    }, 9e5);\n}"
	},
	{
		"fursuitbutt": "async function (msg) {\n    const img = await Yiffy_1.default.furry.butts(\"json\", 1);\n    if (!img)\n        return msg.reply(\"The image api returned an error..\");\n    return msg.reply({\n        embeds: [\n            new EmbedBuilder_1.default(true, msg.author)\n                .setTitle(\"Fursui Butt\")\n                .setImage(img.url)\n                .toJSON()\n        ],\n        components: new ComponentHelper_1.default()\n            .addURLButton(img.shortURL, false, undefined, \"Full Image\")\n            .addURLButton(img.sources[0] || \"https://yiff.rest\", img.sources.length === 0, undefined, \"Source\")\n            .addURLButton(img.reportURL, false, undefined, \"Report\")\n            .toJSON()\n    });\n}"
	},
	{
		"yiff": "async function (msg) {\n    let type;\n    if (msg.args.length === 0) {\n        if (msg.gConfig.settings.defaultYiffType === null)\n            type = _config_1.default.yiffTypes[0];\n        else {\n            if (!_config_1.default.yiffTypes.includes(msg.gConfig.settings.defaultYiffType)) {\n                Logger_1.default.getLogger(\"YiffCommand\").warn(`Unknown Default Yiff Type \"${msg.gConfig.settings.defaultYiffType}\" on guild ${msg.channel.guild.id}`);\n                await msg.gConfig.edit({\n                    settings: {\n                        defaultYiffType: _config_1.default.yiffTypes[0]\n                    }\n                });\n                type = _config_1.default.yiffTypes[0];\n            }\n            else\n                type = msg.gConfig.settings.defaultYiffType;\n        }\n    }\n    else {\n        type = msg.args[0].toLowerCase();\n        if (!_config_1.default.yiffTypes.includes(type))\n            return msg.reply(`Th-that wasn't a valid yiff type! You can use \\`${msg.gConfig.getFormattedPrefix()}help yiff\\` to see them..`);\n    }\n    // I'm proud of this\n    let m;\n    async function refreshImage(id, token) {\n        const y = await Yiffy_1.default.furry.yiff[type](\"json\", 1);\n        const e = new EmbedBuilder_1.default()\n            .setTitle(`${utils_1.Strings.ucwords(type)} Yiff!`)\n            // url buttons\n            /* .setDescription(\n                `[[Short URL]](${y.shortURL})`,\n                `[[Report]](${y.reportURL})`,\n                `${y.sources.length === 0 ? \"[No Source]\" : `[[Source]](${y.sources[0]})`}`\n            ) */\n            .setImage(y.url)\n            .setColor(\"gold\")\n            .toJSON();\n        const c = new ComponentHelper_1.default()\n            .addURLButton(y.shortURL, false, undefined, \"Full Image\")\n            .addURLButton(y.sources[0] || \"https://yiff.rest\", y.sources.length === 0, undefined, \"Source\")\n            .addURLButton(y.reportURL, false, undefined, \"Report\")\n            .addRow()\n            .addInteractionButton(ComponentHelper_1.default.BUTTON_SECONDARY, `new-image.${msg.author.id}`, false, undefined, \"New Image\")\n            .toJSON();\n        if (m === undefined)\n            m = await msg.reply({\n                content: \"H-here's your yiff!\",\n                embeds: [e],\n                components: c\n            });\n        else {\n            if (!id || !token)\n                return;\n            await this.createInteractionResponse(id, token, {\n                type: eris_1.default.Constants.InteractionResponseTypes.UPDATE_MESSAGE,\n                data: {\n                    embeds: [e],\n                    components: c\n                }\n            });\n        }\n        const wait = await msg.channel.awaitComponentInteractions(3e5, (it) => it.channelID === msg.channel.id && it.message.id === m.id && it.data.custom_id.startsWith(\"new-image\") && it.data.custom_id.endsWith(msg.author.id) && it.member.user.id === msg.author.id);\n        if (wait === null) {\n            await m.edit({\n                content: m.content,\n                embeds: m.embeds,\n                components: m.components?.slice(0, 1)\n            });\n            if (t)\n                clearTimeout(t);\n        }\n        else\n            return refreshImage.call(this, wait.id, wait.token);\n    }\n    void refreshImage.call(this);\n    const t = setTimeout(() => {\n        if (m !== undefined)\n            void m.edit({\n                content: m.content,\n                embeds: m.embeds,\n                components: m.components?.slice(0, 1)\n            });\n    }, 9e5);\n}"
	},
	{
		"clean": "async function (msg) {\n    if (msg.args.length === 0)\n        return msg.reply(`H-hey! You have to provide some arguments, silly.. See \\`${msg.gConfig.getFormattedPrefix()}clean help\\` for help`);\n    // assume they provided the arguments backwards\n    if (msg.args.length > 1 && (!isNaN(Number(msg.args[0])) && isNaN(Number(msg.args[1]))))\n        msg.args = [\n            msg.args[1],\n            msg.args[0],\n            ...msg.args.slice(2)\n        ];\n    const amount = Number(msg.args.length === 1 ? msg.args[0] : msg.args[1]);\n    if (amount < 2)\n        return msg.reply(\"H-hey! You have to provide a number 2 or higher!\");\n    if (amount > 1000)\n        return msg.reply(\"H-hey! You have to provide a number 1000 or lower!\");\n    if (isNaN(amount))\n        return msg.reply(\"H-hey! You have to provide a number for the amount!\");\n    let type, target;\n    // all messages\n    if (msg.args.length === 1) {\n        type = \"all\";\n        target = null;\n    }\n    else {\n        switch (msg.args[1]?.toLowerCase()) {\n            // bot messages\n            case \"bot\":\n            case \"bots\": {\n                type = \"bots\";\n                target = null;\n                break;\n            }\n            // command messages\n            case \"commands\": {\n                type = \"commands\";\n                target = null;\n                break;\n            }\n            // text filtered messages\n            case \"text\": {\n                type = \"text\";\n                target = msg.args.slice(2).join(\" \");\n                if (!target)\n                    return msg.reply(\"H-hey! You have to supply some text to look for..\");\n                break;\n            }\n            // specific\n            default: {\n                const user = await msg.getUserFromArgs(1, 0);\n                const role = await msg.getRoleFromArgs(1, 0);\n                const channel = await msg.getChannelFromArgs(0, 0, undefined, undefined, true);\n                if (user !== null) {\n                    type = \"user\";\n                    target = user;\n                }\n                else if (role !== null) {\n                    type = \"role\";\n                    target = role;\n                }\n                else if (channel !== null) {\n                    type = \"channel\";\n                    target = channel;\n                    if (![eris_1.default.Constants.ChannelTypes.GUILD_TEXT, eris_1.default.Constants.ChannelTypes.GUILD_NEWS].includes(channel.type)) {\n                        if ([eris_1.default.Constants.ChannelTypes.GUILD_NEWS_THREAD, eris_1.default.Constants.ChannelTypes.GUILD_PUBLIC_THREAD, eris_1.default.Constants.ChannelTypes.GUILD_PRIVATE_THREAD].includes(channel.type))\n                            return msg.reply(\"H-hey! Sorry! This command doesn't support threads..\");\n                        else\n                            return msg.reply(\"H-hey! Please provide a text channel..\");\n                    }\n                    if (!channel.permissionsOf(this.user.id).has(\"manageMessages\"))\n                        return msg.reply(`H-hey! I don't have the **Manage Messages** permission in <#${channel.id}>..`);\n                }\n                else\n                    return msg.reply(\"I-I couldn't figure out what you were trying to clean up.. try again?\");\n            }\n        }\n    }\n    console.log(amount, type, target?.toString());\n    const ch = type === \"channel\" ? target : msg.channel;\n    await msg.channel.sendTyping();\n    const typing = setInterval(() => msg.channel.sendTyping(), 7e3);\n    const time = setTimeout(() => {\n        clearInterval(typing);\n    }, 7.5e4);\n    async function getMessages(left = amount, old) {\n        const m = await ch.getMessages({\n            limit: left > 100 ? 100 : left,\n            before: old ? old[old.length - 1].id : undefined\n        });\n        left -= 100;\n        if (left > 0)\n            return getMessages(left, [...(old ?? []), ...m]);\n        else\n            return [...(old ?? []), ...m];\n    }\n    //                                 fetch extra for filtering\n    const messages = await getMessages(amount < 100 ? 100 : amount);\n    let filteredDate = 0;\n    const filtered = messages.filter(m => {\n        if (m.createdAt < (Date.now() - 1.21e+9)) {\n            filteredDate++;\n            return false;\n        }\n        else {\n            // let type: \"all\" | \"user\" | \"bots\" | \"channel\" | \"role\" | \"commands\" | \"text\", target: null | Eris.User | Eris.GuildTextableChannel | Eris.Role | string;\n            switch (type) {\n                case \"user\": return m.author.id === target.id;\n                case \"bots\": return m.author.bot;\n                case \"role\": return m.member && m.member.roles.includes(target.id);\n                case \"commands\": return msg.gConfig.prefix.some(p => m.content.toLowerCase().startsWith(p.value));\n                case \"text\": return m.content.toLowerCase().indexOf(target.toLowerCase()) !== -1;\n                default: return true;\n            }\n        }\n    });\n    const count = await msg.reply(`Total Messages Recieved: **${messages.length}**\nOlder Than 2 Weeks: **${filteredDate}**\\nFiltered Out: **${((messages.length - filteredDate) - filtered.length)}**\\n\\nMessages Left Over: **${filtered.length}**\\n Excess Removed: **${filtered.length > amount ? filtered.length - amount : 0}**`);\n    if (filtered.length < 2) {\n        clearInterval(typing);\n        clearTimeout(time);\n        return msg.reply(\"There weren't any messages left over after filtering..\");\n    }\n    clearInterval(typing);\n    clearTimeout(time);\n    const sendCancel = await msg.channel.createMessage(\"Send \\\"cancel\\\" within 5 seconds to cancel message deletion..\");\n    const waitCancel = await MessageCollector_1.default.awaitMessages(msg.channel.id, 5e3, (m) => m.author.id === msg.author.id);\n    if (waitCancel !== null && waitCancel.content.toLowerCase() === \"cancel\") {\n        await count.delete();\n        await sendCancel.delete();\n        await waitCancel.delete().catch(() => null);\n        return msg.reply(\"Cancelled.\");\n    }\n    await sendCancel.edit(\"Running...\");\n    if (filtered.length > amount)\n        filtered.forEach((f, i) => i > (amount + 1) ? filtered.splice(i, 1) : null);\n    const typing2 = setInterval(() => msg.channel.sendTyping(), 7e3);\n    const time2 = setTimeout(() => {\n        clearInterval(typing);\n    }, 6e4);\n    await Promise.all(chunk_1.default(filtered, 100).map(async (m) => ch.deleteMessages(m.map(v => v.id))));\n    clearInterval(typing2);\n    clearTimeout(time2);\n    return sendCancel.edit(`Successfully cleaned up **${filtered.length}** messages. **${filteredDate}** were removed due to them being over 2 weeks old.`);\n}"
	},
	{
		"disable": "async function (msg) {\n    if (msg.args.length < 1)\n        return msg.reply(`H-hey! You used that command wrong.. Try looking at \\`${msg.gConfig.getFormattedPrefix()}help disable\\``);\n    switch (msg.args[0].toLowerCase()) {\n        case \"add\": {\n            const scope = msg.args.length >= 4 ? await msg.getChannelFromArgs(2, 0) : \"server\";\n            if (scope === null)\n                return msg.reply(\"H-hey! That wasn't a valid channel..\");\n            let type, value;\n            switch (msg.args[1]?.toLowerCase()) {\n                case \"all\": {\n                    type = DisableEntry_1.default.ALL;\n                    value = null;\n                    break;\n                }\n                case \"category\": {\n                    if (msg.args.length === 2)\n                        return msg.reply(\"H-hey! A command to disable is required..\");\n                    const cat = CommandHandler_1.default.getCategory(msg.args[2].toLowerCase());\n                    if (cat === null)\n                        return msg.reply(\"H-hey! That wasn't a valid category..\");\n                    type = DisableEntry_1.default.CATEGORY;\n                    value = cat.name;\n                    break;\n                }\n                case \"command\": {\n                    if (msg.args.length === 2)\n                        return msg.reply(\"H-hey! A command to disable is required..\");\n                    const cmd = CommandHandler_1.default.getCommand(msg.args[2].toLowerCase());\n                    if (cmd === null)\n                        return msg.reply(\"H-hey! That wasn't a valid command..\");\n                    if ([\"disable\"].includes(cmd.triggers[0]))\n                        return msg.reply(\"H-hey! That command can't be disabled..\");\n                    type = DisableEntry_1.default.COMMAND;\n                    value = cmd.triggers[0];\n                    break;\n                }\n                default: return msg.reply(`H-hey! You used that command wrong.. Try looking at \\`${msg.gConfig.getFormattedPrefix()}help disable\\``);\n            }\n            await msg.gConfig.addDisableEntry(type, value, scope === \"server\" ? null : scope.id);\n            return msg.reply(`Entry has been added, **#${msg.gConfig.disable.length}**`);\n        }\n    }\n}"
	},
	{
		"editsnipe": "async function (msg) {\n    if (msg.gConfig.settings.snipeDisabled === true)\n        return msg.reply(`H-hey! Snipes are disabled.. This can be changed via \\`${msg.gConfig.getFormattedPrefix()}setting\\``);\n    const ch = msg.args.length === 0 ? msg.channel : await msg.getChannelFromArgs();\n    if (ch === null)\n        return msg.reply(\"H-hey! That channel was invalid..\");\n    const snipe = await Redis.lpop(`snipe:edit:${msg.channel.id}`);\n    if (snipe === null)\n        return msg.reply(\"No edit snipes were found..\");\n    else {\n        const d = JSON.parse(snipe);\n        const len = await Redis.llen(`snipe:edit:${msg.channel.id}`);\n        return msg.reply({\n            embeds: [\n                new EmbedBuilder_1.default(true, msg.author)\n                    .setTitle(\"Edit Snipe\")\n                    .setDescription([\n                    `From <@!${d.author}> - Edited At ${BotFunctions_1.default.formatDiscordTime(d.time, \"short-datetime\", true)}`,\n                    `Old Content: ${utils_1.Strings.truncate(d.oldContent, 125, true)}`,\n                    `New Content: ${utils_1.Strings.truncate(d.newContent, 125, true)}`,\n                    \"\"\n                ].join(\"\n\"))\n                    .setFooter(`UwU | Snipe 1/${len + 1}`)\n                    .toJSON()\n            ]\n        });\n    }\n}"
	},
	{
		"report": "async function (msg) {\n    return msg.reply(\"This feature is currently in development.\");\n    /* if (msg.channel.name.toLowerCase().startsWith(\"user-report-\")) {\n        const [, id] = /^user-report-([a-z\\d]+)$/i.exec(msg.channel.name) ?? [];\n        if (!id) return msg.reply(\"This channel doesn't seem to be a valid report channel..\");\n        const r = await msg.gConfig.getReport(id);\n        if (r === null) return msg.reply(\"I couldn't find the report associated with this channel.\");\n        if (msg.channel.id !== r.channel) return msg.reply(\"This channel is not the original report channel.\");\n        switch (msg.args[0].toLowerCase()) {\n            case \"setreason\": {\n                if (msg.author.id !== r.reportedBy) return msg.reply(\"You are not the creator of this report, so you cannot edit the reason.\");\n                const reason = msg.args.slice(1).join(\" \");\n                if (reason.length > 1250) return msg.reply(\"The reason you provided is too long. Keep it under 1250 characters.\");\n                await r.edit(reason);\n                const u = await this.getUser(r.reportedUser);\n                await msg.channel.edit({\n                    topic: `Reported User: <@!${r.reportedUser}> (${u?.tag || \"Unknown#0000\"})`\n                }, \"\");\n                return msg.reply(\"The reason has been updated.\");\n                break;\n            }\n        }\n    } else {\n    // @TODO config command\n        if (msg.gConfig.reports.enabled !== true) return msg.reply(`H-hey! Reports aren't enabled here.. Please ask a server administrator to enable them via \\`${msg.gConfig.getFormattedPrefix(0)} config reports\\``);\n        switch (msg.gConfig.reports.type) {\n            case \"channel\": {\n                if (msg.gConfig.reports.category === null) return msg.reply(\"H-hey! Reports seem to be misconfigured.. Please ask a server administrator to set the reports category.\");\n                if (msg.gConfig.reports.staffRole === null) return msg.reply(\"H-hey! Reports seem to be misconfigured.. Please ask a server administrator to set the staff role.\");\n                if (!msg.channel.guild.roles.has(msg.gConfig.reports.staffRole)) return msg.reply(\"H-hey! Reports seem to be misconfigured.. Please ask a server administrator to reconfigure the staff role. (issue: staff role does not exist\");\n                const cat = msg.channel.guild.channels.get(msg.gConfig.reports.category) as Eris.CategoryChannel;\n                if (!cat) return msg.reply(\"H-hey! Reports seem to be misconfigured.. Please ask a server administrator to reconfigure the reports category. (issue: channel does not exist)\");\n                if (cat.type !== Eris.Constants.ChannelTypes.GUILD_CATEGORY) return msg.reply(\"H-hey! Reports seem to be misconfigured.. Please ask a server administrator to reconfigure the reports category. (issue: channel is not a category)\");\n                const ch = await this.createChannel(msg.channel.guild.id, \"user-report-new\", Eris.Constants.ChannelTypes.GUILD_TEXT, {\n                    parentID: cat.id,\n                    permissionOverwrites: [\n                        {\n                            type: 0,\n                            id: msg.channel.guild.id, // @everyone\n                            allow: 0n,\n                            deny: Eris.Constants.Permissions.viewChannel\n                        },\n                        {\n                            type: 0,\n                            id: msg.gConfig.reports.staffRole,\n                            allow:\n                            Eris.Constants.Permissions.manageChannels |\n                            Eris.Constants.Permissions.viewChannel |\n                            Eris.Constants.Permissions.sendMessages |\n                            Eris.Constants.Permissions.embedLinks |\n                            Eris.Constants.Permissions.attachFiles |\n                            Eris.Constants.Permissions.readMessageHistory,\n                            deny: 0n\n                        },\n                        {\n                            type: 1,\n                            id: msg.author.id,\n                            allow:\n                            Eris.Constants.Permissions.sendMessages |\n                            Eris.Constants.Permissions.viewChannel |\n                            Eris.Constants.Permissions.embedLinks |\n                            Eris.Constants.Permissions.attachFiles |\n                            Eris.Constants.Permissions.readMessageHistory |\n                            Eris.Constants.Permissions.useExternalEmojis,\n                            deny:\n                            Eris.Constants.Permissions.createInstantInvite |\n                            Eris.Constants.Permissions.useSlashCommands |\n                            Eris.Constants.Permissions.usePublicThreads |\n                            Eris.Constants.Permissions.usePrivateThreads\n                        },\n                        {\n                            type: 1,\n                            id: this.user.id,\n                            allow:\n                            Eris.Constants.Permissions.manageChannels |\n                            Eris.Constants.Permissions.sendMessages |\n                            Eris.Constants.Permissions.viewChannel |\n                            Eris.Constants.Permissions.manageMessages |\n                            Eris.Constants.Permissions.embedLinks |\n                            Eris.Constants.Permissions.attachFiles |\n                            Eris.Constants.Permissions.readMessageHistory |\n                            Eris.Constants.Permissions.useExternalEmojis,\n                            deny: 0n\n                        }\n                    ],\n                    reason: `Report By ${msg.author.tag} (${msg.author.id})`\n                });\n                const m = await ch.createMessage(`<@!${msg.author.id}> Please send either the username (and discriminator, if their username is not unique), or id of the person you are reporting.`);\n                try {\n                    await msg.delete();\n                } catch (e) {\n                    await msg.reply({\n                        content: `<#${ch.id}>`,\n                        allowedMentions: {\n                            repliedUser: true\n                        }\n                    });\n                }\n\n                // eslint-disable-next-line no-inner-declarations\n                async function getUser(this: MaidBoye): Promise<Eris.User | null> {\n                    const userMsgRaw = await MessageCollector.awaitMessages(ch.id, 3e4, (mf) => mf.author.id === msg.author.id);\n                    if (userMsgRaw === null) {\n                        await m.edit({\n                            content: \"\",\n                            embeds: [\n                                new EmbedBuilder()\n                                    .setAuthor(msg.author.tag, msg.author.avatarURL)\n                                    .setTitle(\"Report Timeout\")\n                                    .setColor(\"red\")\n                                    .setDescription(\"Report timed out. This channel will be deleted in 30 seconds.\")\n                                    .toJSON()\n                            ]\n                        });\n                        setTimeout(() => ch.delete(\"Report Timeout\").catch(() => ch.createMessage(\"Failed to delete channel. Please contact a server administrator to clean up this thread.\")), 3e4);\n                        return null;\n                    } else if (userMsgRaw.content.toLowerCase() === \"cancel\") {\n                        await m.edit({\n                            content: \"\",\n                            embeds: [\n                                new EmbedBuilder()\n                                    .setAuthor(msg.author.tag, msg.author.avatarURL)\n                                    .setTitle(\"Report Cancelled\")\n                                    .setColor(\"red\")\n                                    .setDescription(\"Report cancelled. This channel will be deleted in 30 seconds.\")\n                                    .toJSON()\n                            ]\n                        });\n                        setTimeout(() => ch.delete(\"Report Timeout\").catch(() => ch.createMessage(\"Failed to delete channel. Please contact a server administrator to clean up this thread.\")), 3e4);\n                        return null;\n                    }\n                    const userMsg = new ExtendedMessage(userMsgRaw, this);\n                    await userMsg.load();\n                    await userMsgRaw.delete().catch(() => null);\n\n                    const user = await userMsg.getUserFromArgs();\n\n                    if (user === null) {\n                        await m.edit({\n                            content: \"\",\n                            embeds: [\n                                new EmbedBuilder()\n                                    .setTitle(\"Invalid User\")\n                                    .setColor(\"red\")\n                                    .setAuthor(msg.author.tag, msg.author.avatarURL)\n                                    .setDescription(\"We couldn't find a user with what you provided.. Please try again, or provide `cancel` to cancel.\")\n                                    .toJSON()\n                            ]\n                        });\n                        return getUser.call(this);\n                    } else {\n                        await m.edit({\n                            content: \"\",\n                            embeds: [\n                                new EmbedBuilder()\n                                    .setAuthor(msg.author.tag, msg.author.avatarURL)\n                                    .setTitle(\"User Confirmation\")\n                                    .setColor(\"gold\")\n                                    .setDescription(\n                                        \"Is this the user you are reporting?\",\n                                        \"Answer **yes** or **no**.\",\n                                        \"\",\n                                        `User: <@!${user.id}> (\\`${user.tag}\\`)`,\n                                        `ID: \\`${user.id}\\``\n                                    )\n                                    .setImage(user.avatarURL)\n                                    .toJSON()\n                            ]\n                        });\n\n                        const confirmMsg = await MessageCollector.awaitMessages(ch.id, 3e4, (mf) => mf.author.id === msg.author.id);\n                        if (confirmMsg === null) {\n                            await m.edit({\n                                content: \"\",\n                                embeds: [\n                                    new EmbedBuilder()\n                                        .setAuthor(msg.author.tag, msg.author.avatarURL)\n                                        .setTitle(\"Report Timeout\")\n                                        .setColor(\"red\")\n                                        .setDescription(\"Report timed out. This channel will be deleted in 30 seconds.\")\n                                        .toJSON()\n                                ]\n                            });\n                            setTimeout(() => ch.delete(\"Report Timeout\").catch(() => ch.createMessage(\"Failed to delete channel. Please contact a server administrator to clean up this thread.\")), 3e4);\n                            return null;\n                        } else {\n                            await confirmMsg.delete().catch(() => null);\n                            if (confirmMsg.content.toLowerCase() !== \"yes\") {\n                                await m.edit({\n                                    content: \"\",\n                                    embeds: [\n                                        new EmbedBuilder()\n                                            .setAuthor(msg.author.tag, msg.author.avatarURL)\n                                            .setTitle(\"Report Cancelled\")\n                                            .setColor(\"red\")\n                                            .setDescription(\"Report cancelled. This channel will be deleted in 30 seconds.\")\n                                            .toJSON()\n                                    ]\n                                });\n                                setTimeout(() => ch.delete(\"Report Timeout\").catch(() => ch.createMessage(\"Failed to delete channel. Please contact a server administrator to clean up this thread.\")), 3e4);\n                                return null;\n                            } else return user;\n                        }\n                    }\n                }\n\n                const user = await getUser.call(this);\n                if (user === null) return;\n\n                await m.edit({\n                    content: \"\",\n                    embeds: [\n                        new EmbedBuilder()\n                            .setAuthor(msg.author.tag, msg.author.avatarURL)\n                            .setTitle(\"Report Reason\")\n                            .setColor(\"gold\")\n                            .setDescription(\"Got it. Please provide a reason for the report.\")\n                            .setFooter(`Reported User: ${user.tag}`, user.avatarURL)\n                            .toJSON()\n                    ]\n                });\n                const reasonMsg = await MessageCollector.awaitMessages(ch.id, 3e4, (mf) => mf.author.id === msg.author.id);\n                if (reasonMsg === null) {\n                    await m.edit({\n                        content: \"\",\n                        embeds: [\n                            new EmbedBuilder()\n                                .setAuthor(msg.author.tag, msg.author.avatarURL)\n                                .setTitle(\"Report Timeout\")\n                                .setColor(\"red\")\n                                .setDescription(\"Report timed out. This channel will be deleted in 30 seconds.\")\n                                .toJSON()\n                        ]\n                    });\n                    setTimeout(() => ch.delete(\"Report Timeout\").catch(() => ch.createMessage(\"Failed to delete thread. Please contact a server administrator to clean up this thread.\")), 3e4);\n                    return null;\n                } else {\n                    await reasonMsg.delete().catch(() => null);\n                    const r = await msg.gConfig.createReport(msg.author.id, user.id, ch.id, \"channel\", reasonMsg.content);\n\n                    await m.edit({\n                        content: \"\",\n                        embeds: [\n                            new EmbedBuilder()\n                                .setAuthor(msg.author.tag, msg.author.avatarURL)\n                                .setTitle(\"Report Complete\")\n                                .setColor(\"gold\")\n                                .setDescription(\n                                    \"Your report is finished, and has been sent to this server's staff. If they do not reply within 24 hours, this report will be automatically closed.\",\n                                    \"\",\n                                    `Report Id: \\`${r}\\``,\n                                    `User Reported: <@!${user.id}> (${user.tag})`\n                                )\n                                .toJSON()\n                        ]\n                    });\n                    await ch.edit({\n                        name: `user-report-${r}`\n                    });\n                }\n                break;\n            }\n\n            case \"threads\": {\n                if (!msg.channel.guild.features.includes(\"PRIVATE_THREADS\")) return msg.reply(\"This server cannot use this reports type as it does not have access to private threads. Please contact a server administrator to change this.\");\n                const perm = [\"usePrivateThreads\", \"manageThreads\"] as Array<Permissions>;\n                for (const p of perm) if (!msg.channel.guild.me.permissions.has(p)) return msg.reply(`I must have the **${config.permissions[p] ?? p}** permission to run this. If this server does not have access to threads, this command cannot be used. Please contact a server administrator to correct this.`);\n                const t = await this.createThreadWithoutMessage(msg.channel.id, {\n                    type: Eris.Constants.ChannelTypes.GUILD_PRIVATE_THREAD,\n                    autoArchiveDuration: 1440,\n                    name: \"New User Report\"\n                });\n                await t.join(msg.author.id);\n\n                try {\n                    await msg.delete();\n                } catch (e) {\n                    await msg.reply({\n                        content: `<#${t.id}>`,\n                        allowedMentions: {\n                            repliedUser: true\n                        }\n                    });\n                }\n\n                const m = await t.createMessage(`<@!${msg.author.id}> Please send either the username (and discriminator, if their username is not unique), or id of the person you are reporting.`);\n\n                // eslint-disable-next-line no-inner-declarations\n                async function getUser(this: MaidBoye): Promise<Eris.User | null> {\n                    const userMsgRaw = await MessageCollector.awaitMessages(t.id, 3e4, (mf) => mf.author.id === msg.author.id);\n                    if (userMsgRaw === null) {\n                        await m.edit({\n                            content: \"\",\n                            embeds: [\n                                new EmbedBuilder()\n                                    .setAuthor(msg.author.tag, msg.author.avatarURL)\n                                    .setTitle(\"Report Timeout\")\n                                    .setColor(\"red\")\n                                    .setDescription(\"Report timed out. This thread will be deleted in 30 seconds.\")\n                                    .toJSON()\n                            ]\n                        });\n                        setTimeout(() => t.delete().catch(() => t.createMessage(\"Failed to delete thread. Please contact a server administrator to clean up this thread.\")), 3e4);\n                        return null;\n                    } else if (userMsgRaw.content.toLowerCase() === \"cancel\") {\n                        await m.edit({\n                            content: \"\",\n                            embeds: [\n                                new EmbedBuilder()\n                                    .setAuthor(msg.author.tag, msg.author.avatarURL)\n                                    .setTitle(\"Report Cancelled\")\n                                    .setColor(\"red\")\n                                    .setDescription(\"Report cancelled. This thread will be deleted in 30 seconds.\")\n                                    .toJSON()\n                            ]\n                        });\n                        return null;\n                    }\n                    const userMsg = new ExtendedMessage(userMsgRaw, this);\n                    await userMsg.load();\n                    await userMsgRaw.delete().catch(() => null);\n\n                    const user = await userMsg.getUserFromArgs();\n\n                    if (user === null) {\n                        await m.edit({\n                            content: \"\",\n                            embeds: [\n                                new EmbedBuilder()\n                                    .setTitle(\"Invalid User\")\n                                    .setColor(\"red\")\n                                    .setAuthor(msg.author.tag, msg.author.avatarURL)\n                                    .setDescription(\"We couldn't find a user with what you provided.. Please try again, or provide `cancel` to cancel.\")\n                                    .toJSON()\n                            ]\n                        });\n                        return getUser.call(this);\n                    } else {\n                        await m.edit({\n                            content: \"\",\n                            embeds: [\n                                new EmbedBuilder()\n                                    .setAuthor(msg.author.tag, msg.author.avatarURL)\n                                    .setTitle(\"User Confirmation\")\n                                    .setColor(\"gold\")\n                                    .setDescription(\n                                        \"Is this the user you are reporting?\",\n                                        \"Answer **yes** or **no**.\",\n                                        \"\",\n                                        `User: <@!${user.id}> (\\`${user.tag}\\`)`,\n                                        `ID: \\`${user.id}\\``\n                                    )\n                                    .setImage(user.avatarURL)\n                                    .toJSON()\n                            ]\n                        });\n\n                        const confirmMsg = await MessageCollector.awaitMessages(t.id, 3e4, (mf) => mf.author.id === msg.author.id);\n                        if (confirmMsg === null) {\n                            await m.edit({\n                                content: \"\",\n                                embeds: [\n                                    new EmbedBuilder()\n                                        .setAuthor(msg.author.tag, msg.author.avatarURL)\n                                        .setTitle(\"Report Timeout\")\n                                        .setColor(\"red\")\n                                        .setDescription(\"Report timed out. This thread will be deleted in 30 seconds.\")\n                                        .toJSON()\n                                ]\n                            });\n                            setTimeout(() => t.delete().catch(() => t.createMessage(\"Failed to delete thread. Please contact a server administrator to clean up this thread.\")), 3e4);\n                            return null;\n                        } else {\n                            await confirmMsg.delete().catch(() => null);\n                            if (confirmMsg.content.toLowerCase() !== \"yes\") {\n                                await m.edit({\n                                    content: \"\",\n                                    embeds: [\n                                        new EmbedBuilder()\n                                            .setAuthor(msg.author.tag, msg.author.avatarURL)\n                                            .setTitle(\"Report Cancelled\")\n                                            .setColor(\"red\")\n                                            .setDescription(\"Report cancelled. This thread will be deleted in 30 seconds.\")\n                                            .toJSON()\n                                    ]\n                                });\n                                setTimeout(() => t.delete().catch(() => t.createMessage(\"Failed to delete thread. Please contact a server administrator to clean up this thread.\")), 3e4);\n                                return null;\n                            } else return user;\n                        }\n                    }\n                }\n\n                const user = await getUser.call(this);\n                if (user === null) return;\n\n                await m.edit({\n                    content: \"\",\n                    embeds: [\n                        new EmbedBuilder()\n                            .setAuthor(msg.author.tag, msg.author.avatarURL)\n                            .setTitle(\"Report Reason\")\n                            .setColor(\"gold\")\n                            .setDescription(\"Got it. Please provide a reason for the report.\")\n                            .setFooter(`Reported User: ${user.tag}`, user.avatarURL)\n                            .toJSON()\n                    ]\n                });\n                const reasonMsg = await MessageCollector.awaitMessages(t.id, 3e4, (mf) => mf.author.id === msg.author.id);\n                if (reasonMsg === null) {\n                    await m.edit({\n                        content: \"\",\n                        embeds: [\n                            new EmbedBuilder()\n                                .setAuthor(msg.author.tag, msg.author.avatarURL)\n                                .setTitle(\"Report Timeout\")\n                                .setColor(\"red\")\n                                .setDescription(\"Report timed out. This thread will be deleted in 30 seconds.\")\n                                .toJSON()\n                        ]\n                    });\n                    setTimeout(() => t.delete().catch(() => t.createMessage(\"Failed to delete thread. Please contact a server administrator to clean up this thread.\")), 3e4);\n                    return null;\n                } else {\n                    await reasonMsg.delete().catch(() => null);\n                    const r = await msg.gConfig.createReport(msg.author.id, user.id, t.id, \"thread\", reasonMsg.content);\n\n                    await m.edit({\n                        content: \"\",\n                        embeds: [\n                            new EmbedBuilder()\n                                .setAuthor(msg.author.tag, msg.author.avatarURL)\n                                .setTitle(\"Report Complete\")\n                                .setColor(\"gold\")\n                                .setDescription(\n                                    \"Your report is finished, and has been sent to this server's staff. If they do not reply within 24 hours, this will be auto archived.\",\n                                    \"\",\n                                    `Report Id: \\`${r}\\``,\n                                    `User Reported: <@!${user.id}> (${user.tag})`\n                                )\n                                .toJSON()\n                        ]\n                    });\n                    await t.edit({\n                        name: `User Report (${r})`\n                    });\n                }\n                break;\n            }\n\n            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n            default: return msg.reply(`This server's report type (\\`${msg.gConfig.reports.type}\\`) is invalid, please contact a developer.`);\n        }\n    } */\n}"
	},
	{
		"selfroles": "async function (msg, cmd) {\n    if (msg.args.length === 0)\n        return new CommandError_1.default(\"INVALID_USAGE\", cmd);\n    const selfList = msg.uConfig.selfRolesJoined.filter(r => r.guildId === msg.channel.guild.id);\n    switch (msg.args[0].toLowerCase()) {\n        case \"list\": {\n            if (msg.gConfig.selfRoles.size === 0)\n                return msg.reply(\"Th-this server doesnt't have any self roles..\");\n            /* if (selfList.length === 0) return msg.reply(\"Y-you haven't gained any roles via self roles..\");\n            return msg.reply({\n                embeds: [\n                    new EmbedBuilder(true, msg.author)\n                    .setTitle(\"Self Roles List\")\n                    .setDescription(selfList.map(r => `- <@&${r.role}>`))\n                    .toJSON()\n                ]\n            }); */\n            return msg.reply({\n                embeds: [\n                    new EmbedBuilder_1.default(true, msg.author)\n                        .setTitle(\"Self Roles List\")\n                        .setDescription(msg.gConfig.selfRoles.map(r => `- <@&${r.role}>`))\n                        .toJSON()\n                ]\n            });\n            break;\n        }\n        case \"join\": {\n            if (msg.gConfig.selfRoles.size === 0)\n                return msg.reply(\"Th-this server doesnt't have any self roles..\");\n            const roles = msg.gConfig.selfRoles.map(({ role }) => msg.channel.guild.roles.get(role)).filter(r => r.name.toLowerCase().includes(msg.args.slice(1).join(\" \").toLowerCase()));\n            let role;\n            if (roles.length === 1) {\n                role = roles[0];\n                if (msg.member.roles.includes(role.id))\n                    return msg.reply(\"Y-you already have that role!\");\n                else {\n                    await msg.member.addRole(role.id, \"SelfRoles[Join]\");\n                    await msg.uConfig.addSelfRoleJoined(role.id, msg.channel.guild.id);\n                    await msg.uConfig.fix(); // fix removes duplicates\n                    return msg.reply(`Congrats, you now have the <@&${role.id}> role!`);\n                }\n            }\n            else {\n                const makeChoice = await msg.reply({\n                    embeds: [\n                        new EmbedBuilder_1.default(true, msg.author)\n                            .setDescription(`Your search \"${msg.args.slice(1).join(\" \").toLowerCase()}\" matched multiple roles. Please select one.`)\n                            .setColor(\"gold\")\n                            .toJSON()\n                    ],\n                    components: new ComponentHelper_1.default()\n                        .addSelectMenu(`select-role.${msg.author.id}`, roles.map(r => ({\n                        label: r.name,\n                        value: r.id\n                    })), \"Select A Role To Join\", 1, 1)\n                        .addInteractionButton(ComponentHelper_1.default.BUTTON_DANGER, `select-role.${msg.author.id}.cancel`, false, ComponentHelper_1.default.emojiToPartial(_config_1.default.emojis.default.x, \"default\"), \"Cancel\")\n                        .toJSON()\n                });\n                const choice = await ComponentInteractionCollector_1.default.awaitInteractions(msg.channel.id, 3e4, (i) => i.data.custom_id.startsWith(`select-role.${msg.author.id}`) && i.message.id === makeChoice.id && !!i.member?.user && i.member.user.id === msg.author.id);\n                if (choice === null)\n                    return msg.reply(\"Th-this either timed out, or you made an invalid selection..\");\n                await choice.acknowledge();\n                if (choice.data.custom_id.endsWith(\"cancel\"))\n                    return choice.editOriginalMessage({\n                        embeds: [\n                            new EmbedBuilder_1.default(true, msg.author)\n                                .setDescription(\"Cancelled.\")\n                                .setColor(\"red\")\n                                .toJSON()\n                        ],\n                        components: []\n                    });\n                const [made] = choice.data.values;\n                if (!roles.map(r => r.id).includes(made))\n                    return choice.editOriginalMessage({\n                        embeds: [\n                            new EmbedBuilder_1.default(true, msg.author)\n                                .setDescription(\"You made an invalid choice..\")\n                                .setColor(\"red\")\n                                .toJSON()\n                        ],\n                        components: []\n                    });\n                if (msg.member.roles.includes(made))\n                    return choice.editOriginalMessage({\n                        embeds: [\n                            new EmbedBuilder_1.default(true, msg.author)\n                                .setDescription(\"Y-you already have that role!\")\n                                .setColor(\"red\")\n                                .toJSON()\n                        ],\n                        components: []\n                    });\n                await msg.member.addRole(made, \"SelfRoles[Join]\");\n                await msg.uConfig.addSelfRoleJoined(made, msg.channel.guild.id);\n                await msg.uConfig.fix();\n                return choice.editOriginalMessage({\n                    embeds: [\n                        new EmbedBuilder_1.default(true, msg.author)\n                            .setDescription(`Congrats, you now have the <@&${made}> role!`)\n                            .setColor(\"green\")\n                            .toJSON()\n                    ],\n                    components: []\n                });\n            }\n            break;\n        }\n        case \"leave\": {\n            if (msg.gConfig.selfRoles.size === 0)\n                return msg.reply(\"Th-this server doesnt't have any self roles..\");\n            if (selfList.length === 0)\n                return msg.reply(\"Y-you haven't gained any roles via self roles..\");\n            const makeChoice = await msg.reply({\n                embeds: [\n                    new EmbedBuilder_1.default(true, msg.author)\n                        .setDescription(\"Please select a role to leave.\nIf a role you're looking for isn't listed here, and you have the role, you did not join it via self roles. You cannot leave roles that were manually assigned to you by server staff.\")\n                        .setColor(\"gold\")\n                        .toJSON()\n                ],\n                components: new ComponentHelper_1.default()\n                    .addSelectMenu(`select-role.${msg.author.id}`, selfList.map(r => ({\n                    label: msg.channel.guild.roles.get(r.role)?.name ?? `Unknown[${r.role}]`,\n                    value: r.role\n                })), \"Select A Role To Leave\", 1, 1)\n                    .addInteractionButton(ComponentHelper_1.default.BUTTON_DANGER, `select-role.${msg.author.id}.cancel`, false, ComponentHelper_1.default.emojiToPartial(_config_1.default.emojis.default.x, \"default\"), \"Cancel\")\n                    .toJSON()\n            });\n            const choice = await ComponentInteractionCollector_1.default.awaitInteractions(msg.channel.id, 3e4, (i) => i.data.custom_id.startsWith(`select-role.${msg.author.id}`) && i.message.id === makeChoice.id && !!i.member?.user && i.member.user.id === msg.author.id);\n            if (choice === null)\n                return msg.reply(\"Th-this either timed out, or you made an invalid selection..\");\n            await choice.acknowledge();\n            if (choice.data.custom_id.endsWith(\"cancel\"))\n                return choice.editOriginalMessage({\n                    embeds: [\n                        new EmbedBuilder_1.default(true, msg.author)\n                            .setDescription(\"Cancelled.\")\n                            .setColor(\"red\")\n                            .toJSON()\n                    ],\n                    components: []\n                });\n            const [made] = choice.data.values;\n            if (!selfList.map(r => r.role).includes(made))\n                return choice.editOriginalMessage({\n                    embeds: [\n                        new EmbedBuilder_1.default(true, msg.author)\n                            .setDescription(\"You made an invalid choice..\")\n                            .setColor(\"red\")\n                            .toJSON()\n                    ],\n                    components: []\n                });\n            // we can safely assume the role has been deleted or something similar\n            // if they don't have the role at this point\n            // @TODO pull entries from selfRolesJoined on memberUpdate->roleRemove\n            /* if (!msg.member.roles.includes(made)) return this.editOriginalInteractionResponse(this.user.id, choice.token, {\n                embeds: [\n                    new EmbedBuilder(true, msg.author)\n                        .setDescription(\"Y-you don't have that role!\")\n                        .setColor(\"red\")\n                        .toJSON()\n                ],\n                components: []\n            }); */\n            if (msg.member.roles.includes(made))\n                await msg.member.removeRole(made, \"SelfRoles[Leave]\");\n            await msg.uConfig.removeSelfRoleJoined(msg.channel.guild.id, made, \"role\");\n            await msg.uConfig.fix();\n            return choice.editOriginalMessage({\n                embeds: [\n                    new EmbedBuilder_1.default(true, msg.author)\n                        .setDescription(`Congrats, you no longer have the <@&${made}> role.`)\n                        .setColor(\"orange\")\n                        .toJSON()\n                ],\n                components: []\n            });\n            break;\n        }\n        case \"add\": {\n            if (!msg.member.permissions.has(\"manageRoles\"))\n                return msg.reply(\"Y-you must have the **Manage Roles** permission to use this!\");\n            if (msg.args.length === 1)\n                return msg.reply(\"Y-you have to provide a role to add..\");\n            const role = await msg.getRoleFromArgs(1, 0);\n            if (role === null)\n                return msg.reply(\"Th-that wasn't a valid role..\");\n            if (msg.gConfig.selfRoles.map(r => r.role).includes(role.id))\n                return msg.reply(\"Th-that role is already self assignable..\");\n            const compare = role.compareToMember(msg.channel.guild.me);\n            if ([\"higher\", \"same\"].includes(compare))\n                return msg.reply(\"Th-that role is higher than, or the same as my higest role.. I cannot assign it\");\n            await msg.gConfig.addSelfRole(role.id, msg.author.id);\n            return msg.reply(`The role <@&${role.id}> is now self assignable`);\n            break;\n        }\n        case \"remove\": {\n            if (!msg.member.permissions.has(\"manageRoles\"))\n                return msg.reply(\"Y-you must have the **Manage Roles** permission to use this!\");\n            if (msg.gConfig.selfRoles.size === 0)\n                return msg.reply(\"Th-this server doesnt't have any self roles to remove..\");\n            if (msg.args.length === 1)\n                return msg.reply(\"Y-you have to provide a role to remove..\");\n            const role = await msg.getRoleFromArgs(1, 0);\n            if (role === null)\n                return msg.reply(\"Th-that wasn't a valid role..\");\n            if (!msg.gConfig.selfRoles.map(r => r.role).includes(role.id))\n                return msg.reply(\"Th-that role isn't self assignable..\");\n            const r = await msg.gConfig.removeSelfRole(role.id, \"role\");\n            if (r === false)\n                return msg.reply(\"Internal removal function failed..\");\n            return msg.reply(`The role <@&${role.id}> is no longer self assignable`);\n            break;\n        }\n    }\n}"
	},
	{
		"snipe": "async function (msg) {\n    if (msg.gConfig.settings.snipeDisabled === true)\n        return msg.reply(`H-hey! Snipes are disabled.. This can be changed via \\`${msg.gConfig.getFormattedPrefix()}settings\\``);\n    const ch = msg.args.length === 0 ? msg.channel : await msg.getChannelFromArgs();\n    if (ch === null)\n        return msg.reply(\"H-hey! That channel was invalid..\");\n    const snipe = await Redis.lpop(`snipe:delete:${msg.channel.id}`);\n    if (snipe === null)\n        return msg.reply(\"No snipes were found..\");\n    else {\n        const d = JSON.parse(snipe);\n        const len = await Redis.llen(`snipe:delete:${msg.channel.id}`);\n        return msg.reply({\n            embeds: [\n                new EmbedBuilder_1.default(true, msg.author)\n                    .setTitle(\"Delete Snipe\")\n                    .setDescription([\n                    `From <@!${d.author}> - Edited At ${BotFunctions_1.default.formatDiscordTime(d.time, \"short-datetime\", true)}`,\n                    `> ${utils_1.Strings.truncate(d.content, 250, true)}`,\n                    \"\",\n                    ...(d.ref === null ? [] : [\n                        `Replied Message - <@!${d.ref.author}>:`,\n                        `> ${utils_1.Strings.truncate(d.ref.content, 50, true)} [[Jump](${d.ref.link})]`\n                    ])\n                ].join(\"\n\"))\n                    .setFooter(`UwU | Snipe 1/${len + 1}`)\n                    .toJSON()\n            ]\n        });\n    }\n}"
	},
	{
		"steal": "async function (msg, cmd) {\n    if (msg.args.length < 1)\n        return new CommandError_1.default(\"INVALID_USAGE\", cmd);\n    if (msg.args[0].toLowerCase() === \"attachment\") {\n        const [a = null] = msg.attachments.filter(at => at.content_type && at.content_type.startsWith(\"image/\"));\n        if (a !== null)\n            msg.args = [a.url, ...msg.args.slice(1)];\n    }\n    const e = /(?:<a?:(.*):)?([0-9]{15,21})(?:>)?/i.exec(msg.args[0]);\n    // https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_\\+.~#?&//=]*)\n    const id = e?.[2];\n    let name = msg.args.slice(1).join(\" \") || e?.[1] || id, m;\n    if (!id) {\n        if (/https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_+.~#?&//=]*)/.test(msg.args[0])) {\n            const url = new url_1.URL(msg.args[0]);\n            if (!name)\n                name = url.pathname.substring(url.pathname.lastIndexOf(\"/\") + 1).replace(/\\.(png|jpe?g|gif|webp)/, \"\").slice(0, 32);\n            m = await msg.reply(\"Fetching Image...\");\n            await msg.channel.sendTyping();\n        }\n        else\n            return msg.reply(\"I-I couldn't find an emoji or url with what you provided..\");\n    }\n    if (!name)\n        name = \"Unknown\";\n    const img = await node_fetch_1.default(`https://proxy-request.yiff.workers.dev?url=${encodeURIComponent(!id ? msg.args[0] : `https://cdn.discordapp.com/emojis/${id}`)}`, {\n        headers: {\n            \"Authorization\": _config_1.default.apiKeys.proxyReq,\n            \"User-Agent\": _config_1.default.userAgent\n        }\n    });\n    const og = await img.buffer();\n    let b;\n    if (og.byteLength > 256000) {\n        if (m)\n            await m.edit(\"Resizing Image...\");\n        try {\n            b = await tinify_1.default.fromBuffer(og).toBuffer();\n        }\n        catch (err) {\n            if (m)\n                await m.delete();\n            await msg.reply(\"o-our compression service returned an error.. You will need to manually resize t-the provided file to under 256kb..\");\n            Logger_1.default.error(`Error while running Tinify for the url \"${img.url}\",`, err);\n            return;\n        }\n    }\n    else\n        b = og;\n    if (name.length < 2 || name.length > 32)\n        return msg.reply(\"H-hey! The name must be between 2 and 32 characters.\");\n    if (m)\n        await m.delete();\n    if (img.status !== 200)\n        return msg.reply(\"I-I couldn't find an emoji or url with what you provided..\");\n    await msg.channel.guild.createEmoji({\n        name,\n        image: `data:${img.headers.get(\"Content-Type\")};base64,${Buffer.from(b).toString(\"base64\")}`\n    }, encodeURIComponent(`steal command: ${msg.author.tag} (${msg.author.id})`)).then(j => msg.reply(`Created the emoji <${j.animated ? \"a\" : \"\"}:${j.name}:${j.id}> w-with the name **${j.name}**..`)).catch(error => {\n        const err = error;\n        if (\"code\" in err)\n            switch (err.code) {\n                case 30008: return msg.reply(`th-this server already has the maximum amount of emojis (${((/\\((\\d+)\\)/.exec(err.message)) ?? [0])[1]}), so I cannot add any more.`);\n                case 50035: {\n                    if (err.message.indexOf(\"File cannot be larger than 256.0 kb\") !== -1)\n                        return msg.reply(\"I-I wasn't able to resize the provided file under 256kb.. Please manually do this yourself.\");\n                    if (err.message.indexOf(\"name: String value did not match validation regex.\") !== -1)\n                        return msg.reply(\"D-discord didn't like something about the name you provided.. Try again with something else.\");\n                    break;\n                }\n            }\n        return msg.reply(`S-sorry! We failed to create that emoji, reason: **${err.name}: ${err.message}**`);\n    });\n}"
	},
	{
		"tag": "async function (msg) {\n    const sub = msg.rawArgs.length === 0 ? \"help\" : msg.rawArgs[0].toLowerCase();\n    switch (sub) {\n        case \"create\": {\n            if (msg.gConfig.tags.size >= 50)\n                return msg.reply(\"H-hey! This server has hit the tag limit (50).. Either delete some to make more, or contact a developer.\");\n            if (msg.args.length === 1)\n                return msg.reply(\"H-hey! You have to provide a name for the tag..\");\n            if (msg.args.length === 2)\n                return msg.reply(\"H-hey! You have to provide some content for the tag..\");\n            if ([\"create\", \"modify\", \"delete\", \"list\", \"help\", \"get\"].includes(msg.rawArgs[1].toLowerCase()))\n                return msg.reply(`H-hey! That name (**${msg.rawArgs[1].toLowerCase()}**) is a blacklisted name, you can't use it..`);\n            if (msg.gConfig.tags.map(t => t.name).includes(msg.rawArgs[1].toLowerCase()))\n                return msg.reply(\"H-hey! A tag already exists with that name..\");\n            const content = msg.rawArgs.slice(2).join(\" \");\n            if (content.length > 750)\n                return msg.reply(\"H-hey! Tags have a hard limit of 750 characters..\");\n            await msg.gConfig.addTag({\n                name: msg.rawArgs[1].toLowerCase(),\n                content,\n                createdAt: Date.now(),\n                createdBy: msg.author.id\n            });\n            return msg.reply({\n                content: `successfully created the tag **${msg.rawArgs[1].toLowerCase()}**, with the content:`,\n                embeds: [\n                    new EmbedBuilder_1.default()\n                        .setAuthor(msg.author.tag, msg.author.avatarURL)\n                        .setDescription(msg.rawArgs.slice(2).join(\" \"))\n                        .toJSON()\n                ]\n            });\n            break;\n        }\n        case \"modify\": {\n            if (msg.gConfig.tags.size === 0)\n                return msg.reply(\"th-this server doesn't have any tags to modify..\");\n            if (msg.args.length === 1)\n                return msg.reply(\"H-hey! You have to provide a name for the tag..\");\n            if (msg.args.length === 2)\n                return msg.reply(\"H-hey! You have to provide some content for the tag..\");\n            if ([\"create\", \"modify\", \"delete\", \"list\", \"help\", \"get\"].includes(msg.rawArgs[1].toLowerCase()))\n                return msg.reply(`H-hey! That name (**${msg.rawArgs[1].toLowerCase()}**) is a blacklisted name, you can't use it..`);\n            if (msg.gConfig.tags.map(t => t.name).includes(msg.rawArgs[1].toLowerCase()))\n                return msg.reply(\"H-hey! A tag already exists with that name..\");\n            const t = msg.gConfig.tags.find(tag => tag.name === msg.rawArgs[1].toLowerCase());\n            if (!t)\n                return msg.reply(`I couldn't find a tag with the name \"${msg.rawArgs[1].toLowerCase()}\"..`);\n            const content = msg.rawArgs.slice(2).join(\" \");\n            if (content.length > 750)\n                return msg.reply(\"H-hey! Tags have a hard limit of 750 characters..\");\n            await msg.gConfig.editTag(t.id, \"id\", content, msg.author.id);\n            return msg.reply({\n                content: `successfully modified the tag **${msg.rawArgs[1].toLowerCase()}**`,\n                embeds: [\n                    new EmbedBuilder_1.default()\n                        .setAuthor(msg.author.tag, msg.author.avatarURL)\n                        .addField(\"Old Content\", t.content, false)\n                        .addField(\"New Content\", msg.rawArgs.slice(2).join(\" \"), false)\n                        .toJSON()\n                ]\n            });\n            break;\n        }\n        case \"delete\": {\n            if (msg.gConfig.tags.size === 0)\n                return msg.reply(\"th-this server doesn't have any tags to delete..\");\n            if (msg.args.length === 1)\n                return msg.reply(\"H-hey! You have to provide the name of a tag to delete..\");\n            if ([\"create\", \"modify\", \"delete\", \"list\", \"help\", \"get\"].includes(msg.rawArgs[1].toLowerCase()))\n                return msg.reply(`H-hey! That name (**${msg.rawArgs[1].toLowerCase()}**) is a blacklisted name, you can't use it..`);\n            const t = msg.gConfig.tags.find(tag => tag.name === msg.rawArgs[1].toLowerCase());\n            if (!t)\n                return msg.reply(`I couldn't find a tag with the name \"${msg.rawArgs[1].toLowerCase()}\"..`);\n            await msg.gConfig.removeTag(t.id, \"id\");\n            return msg.reply(`successfully deleted the tag **${t.name}**`);\n            break;\n        }\n        case \"list\": {\n            if (msg.gConfig.tags.size === 0)\n                return msg.reply(\"th-this server doesn't have any tags to list..\");\n            const page = Number(msg.rawArgs[1]) ?? 1;\n            const pages = chunk_1.default(msg.gConfig.tags.toArray(), 10);\n            if (isNaN(page))\n                return msg.reply(`H-hey! You can't need to specify a valid page number between **1** and **${pages.length}**..`);\n            if (page < 1)\n                return msg.reply(\"H-hey! You can't supply a page less than one!\");\n            if (page > pages.length)\n                return msg.reply(`H-hey! You can't supply a page greater than **${pages.length}**!`);\n            const tags = [];\n            for (const tag of pages[page - 1]) {\n                const i = pages[page - 1].indexOf(tag);\n                const creator = await this.getUser(tag.createdBy);\n                const modifier = tag.modifiedBy === null ? null : await this.getUser(tag.modifiedBy);\n                tags.push([\n                    `#${(i + ((page - 1) * 10)) + 1} - \\`${tag.name}\\``,\n                    `Created By: ${creator === null ? tag.createdBy : `**${creator.tag}** (<@!${creator.id}>)`}`,\n                    `Created At: ${BotFunctions_1.default.formatDiscordTime(tag.createdAt, \"long-datetime\", true)}`,\n                    ...(!(tag.modifiedAt && tag.modifiedBy) ? [] : [\n                        `Modified By: ${modifier === null ? tag.modifiedBy : `**${modifier.tag}** (<@!${modifier.id}>)`}`,\n                        `Modified At: ${BotFunctions_1.default.formatDiscordTime(tag.modifiedAt, \"long-datetime\", true)}`\n                    ]),\n                    \"\"\n                ]);\n            }\n            return msg.reply({\n                embeds: [\n                    new EmbedBuilder_1.default()\n                        .setAuthor(msg.author.tag, msg.author.avatarURL)\n                        .setFooter(`UwU | Page ${page}/${pages.length}${page !== pages.length ? ` | ${msg.gConfig.getFormattedPrefix(0)}tags list ${page + 1}` : \"\"}`)\n                        .setDescription(tags[0], ...tags.slice(1))\n                        .toJSON()\n                ]\n            });\n            break;\n        }\n        case \"help\": {\n            return msg.reply({\n                embeds: [\n                    new EmbedBuilder_1.default()\n                        .setAuthor(msg.author.tag, msg.author.avatarURL)\n                        .setTitle(\"Tag Help\")\n                        .setDescription(\"(techincal note: **tags** and **tag** refer to the same command)\", `**Create**: \\`${msg.gConfig.getFormattedPrefix(0)}tags create <name> <content>\\``, `**Modify**: \\`${msg.gConfig.getFormattedPrefix(0)}tags modify <name> <newcontent>\\``, `**Delete**: \\`${msg.gConfig.getFormattedPrefix(0)}tags delete <name>\\``, `**List**: \\`${msg.gConfig.getFormattedPrefix(0)}tags list [page]\\``, `**Help**: \\`${msg.gConfig.getFormattedPrefix(0)}tags help\\``, `**Get**: \\`${msg.gConfig.getFormattedPrefix(0)}tag <name>\\``)\n                        .toJSON()\n                ]\n            });\n            break;\n        }\n        default: {\n            let name = msg.args[0].toLowerCase();\n            // this is mainly for slash command support\n            if (name === \"get\")\n                name = msg.args[1].toLowerCase();\n            if (!name)\n                return msg.reply(`Y-you have to specify a tag name or sub commend.. Use \\`${msg.gConfig.getFormattedPrefix(0)}tag help\\` if you need help.`);\n            const t = msg.gConfig.tags.find(tag => tag.name === name);\n            if (!t)\n                return msg.reply(`I-I couldn't find a tag with the name \"${name}\".. Use \\`${msg.gConfig.getFormattedPrefix(0)}tag help\\` if you need help.`);\n            // I still want links to be shown and such, so we use a reply, instead of an embed\n            // we do a reply instead of a standalone message so there's some blame for where the message is coming from\n            // so people can't pull a Dank Memer on us\n            return msg.reply(t.content);\n        }\n    }\n}"
	}
]