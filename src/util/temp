class GuildConfig {
    id;
    prefix;
    tags = new collections_1.Collection();
    selfRoles = new collections_1.Collection();
    logEvents;
    disable;
    modlog;
    settings;
    constructor(id, data, prefixData, selfRolesData, tagsData, logEventsData, disableData) {
        this.id = id;
        this.load(data, prefixData, selfRolesData, tagsData, logEventsData, disableData);
    }
    load(data, prefixData, selfRolesData, tagsData, logEventsData, disableData) {
        this.id = data.id;
        this.prefix = prefixData.map(d => new Prefix_1.default(d, this));
        this.tags.clear();
        tagsData.forEach(d => this.tags.set(d.name, new Tag_1.default(d, this)));
        this.selfRoles.clear();
        selfRolesData.forEach(d => this.selfRoles.set(d.role, new SelfRole_1.default(d, this)));
        this.logEvents = logEventsData.map(l => new LogEvent_1.default(l, this));
        this.disable = disableData.map(d => new DisableEntry_1.default(d, this));
        this.modlog = {
            enabled: Boolean(data.modlog_enabled),
            caseEditingEnabled: Boolean(data.modlog_case_editing_enabled),
            caseDeletingEnabled: Boolean(data.modlog_case_deleting_enabled),
            editOthersCasesEnabled: Boolean(data.modlog_edit_others_cases_enabled),
            webhook: data.modlog_webhook_id === null || data.modlog_webhook_token === null || data.modlog_webhook_channel_id === null ? null : {
                id: data.modlog_webhook_id,
                token: data.modlog_webhook_token,
                channelId: data.modlog_webhook_channel_id
            }
        };
        this.settings = {
            defaultYiffType: data.settings_default_yiff_type,
            e621ThumbnailType: data.settings_e621_thumbnail_type,
            muteRole: data.settings_mute_role,
            commandImages: Boolean(data.settings_command_images),
            snipeDisabled: Boolean(data.settings_snipe_disabled)
        };
        return this;
    }
    async reload() {
        const v = await _db_1.default.getGuild(this.id, true, true);
        if (!v)
            throw new Error(`Unexpected undefined on GuildConfig#reload (id: ${this.id})`);
        this.load(v.guild, v.prefix, v.selfRoles, v.tags, v.logEvents, v.disable);
        return this;
    }
    async edit(data) {
        if (data.prefix)
            throw new TypeError("Field 'prefix' cannot be used in the generic edit function.");
        if (data.tags)
            throw new TypeError("Field 'tags' cannot be used in the generic edit function.");
        if (data.selfRoles)
            throw new TypeError("Field 'selfRoles' cannot be used in the generic edit function.");
        if (data.logEvents)
            throw new TypeError("Field 'logEvents' cannot be used in the generic edit function.");
        if (data.disable)
            throw new TypeError("Field 'disable' cannot be used in the generic edit function.");
        const v = {
            modlog_enabled: data.modlog === undefined || data.modlog.enabled === undefined ? undefined : Boolean(data.modlog.enabled) === true ? 1 : 0,
            modlog_case_editing_enabled: data.modlog === undefined || data.modlog.caseEditingEnabled === undefined ? undefined : Boolean(data.modlog.caseEditingEnabled) === true ? 1 : 0,
            modlog_case_deleting_enabled: data.modlog === undefined || data.modlog.caseDeletingEnabled === undefined ? undefined : Boolean(data.modlog.caseDeletingEnabled) === true ? 1 : 0,
            modlog_edit_others_cases_enabled: data.modlog === undefined || data.modlog.editOthersCasesEnabled === undefined ? undefined : Boolean(data.modlog.editOthersCasesEnabled) === true ? 1 : 0,
            modlog_webhook_id: data.modlog === undefined || data.modlog.webhook === undefined ? undefined : data.modlog.webhook === null ? null : data.modlog.webhook.id ?? undefined,
            modlog_webhook_token: data.modlog === undefined || data.modlog.webhook === undefined ? undefined : data.modlog.webhook === null ? null : data.modlog.webhook.token ?? undefined,
            modlog_webhook_channel_id: data.modlog === undefined || data.modlog.webhook === undefined ? undefined : data.modlog.webhook === null ? null : data.modlog.webhook.channelId ?? undefined,
            settings_default_yiff_type: data.settings === undefined ? undefined : data.settings.defaultYiffType ?? undefined,
            settings_e621_thumbnail_type: data.settings === undefined ? undefined : data.settings.e621ThumbnailType ?? undefined,
            settings_mute_role: data.settings === undefined ? undefined : data.settings.muteRole === null ? null : data.settings.muteRole ?? undefined,
            settings_command_images: data.settings === undefined ? undefined : Boolean(data.settings.commandImages) === true ? 1 : 0,
            settings_snipe_disabled: data.settings === undefined ? undefined : Boolean(data.settings.snipeDisabled) === true ? 1 : 0
        };
        const keys = Object.keys(v).filter(k => v[k] !== undefined);
        const values = Object.values(v).filter(k => k !== undefined);
        // for debug
        /* console.log("data", data);
        console.log("obj", v);
        console.log("Query:", `UPDATE guilds SET ${keys.map(j => `${j}=?`).join(", ")} WHERE id = ?`);
        console.log("Parameters:", [...values, this.id]); */
        await _db_1.default.query(`UPDATE guilds SET ${keys.map(j => `${j}=?`).join(", ")} WHERE id = ?`, [...values, this.id]);
        return this.reload();
    }
    async fix() {
        // nothing to fix yet, so this is just blank
        const obj = {};
        if (JSON.stringify(obj) !== "{}")
            await this.edit(obj);
    }
    getFormattedPrefix(index = 0) {
        return BotFunctions_1.default.formatPrefix(this.prefix[index]);
    }
    async addTag(tag) {
        const id = crypto_1.default.randomBytes(6).toString("hex");
        await _db_1.default.query("INSERT INTO tags (id, guild_id, name, content, created_at, created_by, modified_at, modified_by) VALUES (?, ?, ?, ?, ?, ?, ?, ?)", [
            id,
            this.id,
            tag.name,
            tag.content,
            tag.createdAt,
            tag.createdBy,
            tag.modifiedAt ?? null,
            tag.modifiedBy ?? null
        ]);
        return id;
    }
    async editTag(value, column, content, blame) {
        const res = await _db_1.default.query(`UPDATE tags SET content=?, modified_at=?, modified_by=? WHERE ${column}=?`, [content, Date.now(), blame ?? null, value]).then((r) => r.affectedRows > 0);
        if (res === false)
            return false;
        await this.reload();
        return true;
    }
    async removeTag(value, column) {
        return _db_1.default.query(`DELETE FROM tags WHERE ${column}=? AND guild_id=?`, [value, this.id]).then((r) => r.affectedRows > 0);
    }
    async resetTags() {
        const res = await _db_1.default.query("DELETE FROM tags WHERE guild_id=?", [this.id]).then((r) => r.affectedRows > 0);
        if (res === false)
            return false;
        await this.reload();
        return true;
    }
    async addPrefix(value, space = false) {
        const id = crypto_1.default.randomBytes(6).toString("hex");
        await _db_1.default.query("INSERT INTO prefix (id, guild_id, value, space) VALUES (?, ?, ?, ?)", [
            id,
            this.id,
            value,
            space
        ]);
        await this.reload();
        return id;
    }
    async removePrefix(value, column) {
        const res = await _db_1.default.query(`DELETE FROM prefix WHERE ${column}=? AND guild_id=?`, [value, this.id]).then((r) => r.affectedRows > 0);
        if (res === false)
            return false;
        await this.reload();
        return true;
    }
    async resetPrefixes() {
        const res = await _db_1.default.query("DELETE FROM prefix WHERE guild_id=?", [this.id]).then((r) => r.affectedRows > 0);
        await this.addPrefix(_config_1.default.defaults.prefix, true);
        if (res === false)
            return false;
        await this.reload();
        return true;
    }
    async addLogEvent(event, channel) {
        const id = crypto_1.default.randomBytes(6).toString("hex");
        await _db_1.default.query("INSERT INTO logevents (id, guild_id, event, channel) VALUES (?, ?, ?, ?)", [
            id,
            this.id,
            event,
            channel
        ]);
        await this.reload();
        return id;
    }
    async removeLogEvent(event, channel) {
        const res = await _db_1.default.query("DELETE FROM logevents WHERE event=? AND channel=? AND guild_id=?", [event, channel, this.id]).then((r) => r.affectedRows > 0);
        if (res === false)
            return false;
        await this.reload();
        return true;
    }
    async resetLogEvents() {
        const res = await _db_1.default.query("DELETE FROM logevents WHERE guild_id=?", [this.id]).then((r) => r.affectedRows > 0);
        if (res === false)
            return false;
        await this.reload();
        return true;
    }
    async addSelfRole(role, blame) {
        const id = crypto_1.default.randomBytes(6).toString("hex");
        await _db_1.default.query("INSERT INTO selfroles (id, guild_id, role, added_at, added_by) VALUES (?, ?, ?, ?, ?)", [
            id,
            this.id,
            role,
            Date.now(),
            blame
        ]);
        await this.reload();
        return id;
    }
    async removeSelfRole(value, column) {
        const res = await _db_1.default.query(`DELETE FROM selfroles WHERE ${column}=? AND guild_id=?`, [value, this.id]).then((r) => r.affectedRows > 0);
        if (res === false)
            return false;
        await this.reload();
        return true;
    }
    async resetSelfRoles() {
        const res = await _db_1.default.query("DELETE FROM selfroles guild_id=?", [this.id]).then((r) => r.affectedRows > 0);
        if (res === false)
            return false;
        await this.reload();
        return true;
    }
    async addDisableEntry(type, value, channel) {
        const id = crypto_1.default.randomBytes(6).toString("hex");
        await _db_1.default.query("INSERT INTO disable (id, guild_id, type, value, channel) VALUES (?, ?, ?, ?, ?)", [
            id,
            this.id,
            type,
            value,
            channel
        ]);
        await this.reload();
        return id;
    }
    async removeDisableEntry(id) {
        const res = await _db_1.default.query("DELETE FROM disable WHERE id=? AND guild_id=?", [id, this.id]).then((r) => r.affectedRows > 0);
        if (res === false)
            return false;
        await this.reload();
        return true;
    }
    async resetDisableEntries() {
        const res = await _db_1.default.query("DELETE FROM disable guild_id=?", [this.id]).then((r) => r.affectedRows > 0);
        if (res === false)
            return false;
        await this.reload();
        return true;
    }
    async editModlog(entryId, reason, blame) {
        const res = await _db_1.default.query("UPDATE modlog SET reason=?, last_edited_at=?, last_edited_by=? WHERE guild_id=? AND entry_id=?", [reason, Date.now(), blame ?? null, this.id, entryId]).then((r) => r.affectedRows > 0);
        if (res === false)
            return false;
        await this.reload();
        return true;
    }
    async removeModlog(id) {
        const res = await _db_1.default.query("DELETE FROM modlog WHERE id=?", [id]).then((r) => r.affectedRows > 0);
        if (res === false)
            return false;
        await this.reload();
        return true;
    }
    async getModlogEntry(id) {
        const [res] = await _db_1.default.query("SELECT * FROM modlog WHERE guild_id=? AND entry_id=?", [this.id, id]).then(v => v);
        if (res === undefined)
            return null;
        switch (res.type) {
            case "ban": return new All_1.BanEntry(res, this);
            case "clearwarnings": return new All_1.ClearWarningsEntry(res, this);
            case "deletewarning": return new All_1.DeleteWarningEntry(res, this);
            case "kick": return new All_1.KickEntry(res, this);
            case "lockdown": return new All_1.LockDownEntry(res, this);
            case "lock": return new All_1.LockEntry(res, this);
            case "mute": return new All_1.MuteEntry(res, this);
            case "softban": return new All_1.SoftBanEntry(res, this);
            case "unban": return new All_1.UnBanEntry(res, this);
            case "unlockdown": return new All_1.UnLockDownEntry(res, this);
            case "unlock": return new All_1.UnLockEntry(res, this);
            case "unmute": return new All_1.UnMuteEntry(res, this);
            case "warn": return new All_1.WarnEntry(res, this);
        }
        /* return Promise.all(res.map(async(v) => {
            switch (v.type) {
                case "ban": return new BanEntry(v, this);
                case "clearwarnings": return new ClearWarningsEntry(v, this);
                case "deletewarning": return new DeleteWarningEntry(v, this);
                case "kick": return new KickEntry(v, this);
                case "lockdown": return new LockDownEntry(v, this);
                case "lock": return new LockEntry(v, this);
                case "mute": return new MuteEntry(v, this);
                case "softban": return new SoftBanEntry(v, this);
                case "unban": return new UnBanEntry(v, this);
                case "unlockdown": return new UnLockDownEntry(v, this);
                case "unlock": return new UnLockEntry(v, this);
                case "unmute": return new UnMuteEntry(v, this);
                case "warn": return new WarnEntry(v, this);
            }
        })); */
    }
    async checkBlacklist() {
        const res = await _db_1.default.query("SELECT * FROM blacklist WHERE guild_id=?", [this.id]).then((r) => r.map(b => new Blacklist_1.default(b)));
        return {
            active: res.filter(b => b.active),
            expired: res.filter(b => b.expired),
            noticeShown: {
                active: res.filter(b => b.active && b.noticeShown),
                expired: res.filter(b => b.expired && b.noticeShown)
            },
            noticeNotShown: {
                active: res.filter(b => b.active && !b.noticeShown),
                expired: res.filter(b => b.expired && !b.noticeShown)
            }
        };
    }
    async addBlacklist(createdBy, createdByTag, reason, expiry, report) {
        await _db_1.default.createGuildIfNotExists(this.id); // prototype calls
        const d = Date.now();
        const id = crypto_1.default.randomBytes(6).toString("hex");
        await _db_1.default.query("INSERT INTO blacklist (id, guild_id, type, reason, expire_time, created_by, created_by_tag, created_at, report) VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?)", [
            id,
            this.id,
            Blacklist_1.default.GUILD,
            reason,
            expiry ?? 0,
            createdBy,
            createdByTag,
            d,
            report
        ]);
        await WebhookStore_1.default.execute("blacklist", {
            embeds: [
                new EmbedBuilder_1.default()
                    .setTitle("New Guild Blacklist")
                    .setDescription([
                    `Guild: ${WebhookStore_1.default.client.guilds.get(this.id)?.name ?? "Unknown"} (${this.id})`,
                    `Reason: ${reason ?? "None Provided."}`,
                    `Expiry: ${(expiry ?? 0) === 0 ? "Never" : BotFunctions_1.default.formatDiscordTime(expiry, "short-datetime", true)}`,
                    `Created By: ${createdByTag} (${createdBy})`
                ].join("\n"))
                    .toJSON()
            ]
        });
        const [res] = await _db_1.default.query("SELECT * FROM blacklist WHERE guild_id=? AND id=? LIMIT 1", [this.id, id]).then((r) => r.map(b => new Blacklist_1.default(b)));
        return res;
    }
}